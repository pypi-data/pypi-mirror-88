from typing import Any, Optional

TaskType = type

class Context:
    logfile: Any = ...
    loglevel: Any = ...
    hostname: Any = ...
    id: Any = ...
    args: Any = ...
    kwargs: Any = ...
    retries: int = ...
    eta: Any = ...
    expires: Any = ...
    is_eager: bool = ...
    headers: Any = ...
    delivery_info: Any = ...
    reply_to: Any = ...
    root_id: Any = ...
    parent_id: Any = ...
    correlation_id: Any = ...
    taskset: Any = ...
    group: Any = ...
    chord: Any = ...
    chain: Any = ...
    utc: Any = ...
    called_directly: bool = ...
    callbacks: Any = ...
    errbacks: Any = ...
    timelimit: Any = ...
    origin: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def update(self, *args: Any, **kwargs: Any): ...
    def clear(self): ...
    def get(self, key: Any, default: Optional[Any] = ...): ...
    def as_execution_options(self): ...
    @property
    def children(self): ...

class Task:
    __trace__: Any = ...
    __v2_compat__: bool = ...
    MaxRetriesExceededError: Any = ...
    OperationalError: Any = ...
    Strategy: str = ...
    Request: str = ...
    name: Any = ...
    typing: Any = ...
    max_retries: int = ...
    default_retry_delay: Any = ...
    rate_limit: Any = ...
    ignore_result: Any = ...
    trail: bool = ...
    send_events: bool = ...
    store_errors_even_if_ignored: Any = ...
    serializer: Any = ...
    time_limit: Any = ...
    soft_time_limit: Any = ...
    backend: Any = ...
    autoregister: bool = ...
    track_started: Any = ...
    acks_late: Any = ...
    acks_on_failure_or_timeout: Any = ...
    reject_on_worker_lost: Any = ...
    throws: Any = ...
    expires: Any = ...
    priority: Any = ...
    resultrepr_maxsize: int = ...
    request_stack: Any = ...
    abstract: bool = ...
    __bound__: bool = ...
    from_config: Any = ...
    @classmethod
    def bind(cls, app: Any): ...
    @classmethod
    def on_bound(cls, app: Any) -> None: ...
    app: Any = ...
    @classmethod
    def annotate(cls) -> None: ...
    @classmethod
    def add_around(cls, attr: Any, around: Any) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...
    def __reduce__(self): ...
    def run(self, *args: Any, **kwargs: Any) -> None: ...
    def start_strategy(self, app: Any, consumer: Any, **kwargs: Any): ...
    def delay(self, *args: Any, **kwargs: Any): ...
    def apply_async(self, args: Optional[Any] = ..., kwargs: Optional[Any] = ..., task_id: Optional[Any] = ..., producer: Optional[Any] = ..., link: Optional[Any] = ..., link_error: Optional[Any] = ..., shadow: Optional[Any] = ..., **options: Any): ...
    def shadow_name(self, args: Any, kwargs: Any, options: Any) -> None: ...
    def signature_from_request(self, request: Optional[Any] = ..., args: Optional[Any] = ..., kwargs: Optional[Any] = ..., queue: Optional[Any] = ..., **extra_options: Any): ...
    subtask_from_request: Any = ...
    def retry(self, args: Optional[Any] = ..., kwargs: Optional[Any] = ..., exc: Optional[Any] = ..., throw: bool = ..., eta: Optional[Any] = ..., countdown: Optional[Any] = ..., max_retries: Optional[Any] = ..., **options: Any): ...
    def apply(self, args: Optional[Any] = ..., kwargs: Optional[Any] = ..., link: Optional[Any] = ..., link_error: Optional[Any] = ..., task_id: Optional[Any] = ..., retries: Optional[Any] = ..., throw: Optional[Any] = ..., logfile: Optional[Any] = ..., loglevel: Optional[Any] = ..., headers: Optional[Any] = ..., **options: Any): ...
    def AsyncResult(self, task_id: Any, **kwargs: Any): ...
    def signature(self, args: Optional[Any] = ..., *starargs: Any, **starkwargs: Any): ...
    subtask: Any = ...
    def s(self, *args: Any, **kwargs: Any): ...
    def si(self, *args: Any, **kwargs: Any): ...
    def chunks(self, it: Any, n: Any): ...
    def map(self, it: Any): ...
    def starmap(self, it: Any): ...
    def send_event(self, type_: Any, retry: bool = ..., retry_policy: Optional[Any] = ..., **fields: Any): ...
    def replace(self, sig: Any): ...
    def add_to_chord(self, sig: Any, lazy: bool = ...): ...
    def update_state(self, task_id: Optional[Any] = ..., state: Optional[Any] = ..., meta: Optional[Any] = ..., **kwargs: Any) -> None: ...
    def on_success(self, retval: Any, task_id: Any, args: Any, kwargs: Any) -> None: ...
    def on_retry(self, exc: Any, task_id: Any, args: Any, kwargs: Any, einfo: Any) -> None: ...
    def on_failure(self, exc: Any, task_id: Any, args: Any, kwargs: Any, einfo: Any) -> None: ...
    def after_return(self, status: Any, retval: Any, task_id: Any, args: Any, kwargs: Any, einfo: Any) -> None: ...
    def add_trail(self, result: Any): ...
    def push_request(self, *args: Any, **kwargs: Any) -> None: ...
    def pop_request(self) -> None: ...
    request: Any = ...
    @property
    def backend(self): ...
    @backend.setter
    def backend(self, value: Any) -> None: ...
    @property
    def __name__(self): ...
BaseTask = Task
