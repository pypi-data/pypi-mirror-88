# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: demo/v1/echo.proto
# plugin: python-betterproto
import logging


import allure
from dataclasses import dataclass

import betterproto


@dataclass
class EchoEchoReq(betterproto.Message):
    # FIXME 请求字段必须写注释
    msg: str = betterproto.string_field(1)


@dataclass
class EchoEchoResp(betterproto.Message):
    # FIXME 响应字段必须写注释
    msg: str = betterproto.string_field(1)


class EchoStub(betterproto.ServiceStub):
    """FIXME 服务必须写注释"""

    @allure.step(
        """
        FIXME 接口必须写注释 这里的行尾注释 sniper:foo 有特殊含义，是可选的 框架会将此处冒号后面的值(foo)注入到 ctx 中，
        用户可以使用 twirp.MethodOption(ctx) 查询，并执行不同的逻辑 这个 sniper 前缀可以通过
        --twirp_out=option_prefix=sniper:. 自定义
        """
    )
    def echo(self, request: EchoEchoReq) -> EchoEchoResp:
        """
        FIXME 接口必须写注释 这里的行尾注释 sniper:foo 有特殊含义，是可选的 框架会将此处冒号后面的值(foo)注入到 ctx 中，
        用户可以使用 twirp.MethodOption(ctx) 查询，并执行不同的逻辑 这个 sniper 前缀可以通过
        --twirp_out=option_prefix=sniper:. 自定义
        """
        logging.getLogger(__name__).info(
            "start call "
            + "[echo]"
            + " api"
            + "=>"
            + """
        FIXME 接口必须写注释 这里的行尾注释 sniper:foo 有特殊含义，是可选的 框架会将此处冒号后面的值(foo)注入到 ctx 中，
        用户可以使用 twirp.MethodOption(ctx) 查询，并执行不同的逻辑 这个 sniper 前缀可以通过
        --twirp_out=option_prefix=sniper:. 自定义
        """
        )
        response = EchoEchoResp()
        self._do_twirp_rpc("/demo.v1.Echo/Echo", request, response)
        logging.getLogger(__name__).info("call " + "[echo]" + " api success!")
        return response
