{"version":3,"sources":["webpack:///./app/views/performance/transactionVitals/constants.tsx","webpack:///./app/views/events/searchBar.tsx","webpack:///./app/utils/withTags.tsx","webpack:///./app/utils/measurements/measurements.tsx","webpack:///./app/views/eventsV2/table/queryField.tsx"],"names":["NUM_BUCKETS","PERCENTILE","WEB_VITAL_DETAILS","WebVital","FP","slug","name","t","acronym","description","failureThreshold","type","measurementType","FCP","LCP","FID","CLS","TTFB","RequestTime","LONG_WEB_VITAL_NAMES","Object","fromEntries","values","map","value","WEB_VITAL_ACRONYMS","FILTER_OPTIONS","label","_VITAL_GROUPS","vitals","min","precision","_COLORS","theme","charts","getColorPalette","reduce","count","length","reverse","VITAL_GROUPS","group","colors","splice","ZOOM_KEYS","keys","forEach","vital","vitalSlug","push","SEARCH_SPECIAL_CHARS_REGEXP","RegExp","NEGATION_OPERATOR","SEARCH_WILDCARD","SearchBar","getEventFieldValues","memoize","tag","query","endpointParams","props","api","organization","projectIds","projectIdStrings","String","isAggregateField","key","isMeasurement","Promise","resolve","fetchTagValues","then","results","flatten","filter","defined","Error","prepareQuery","replace","this","cache","clear","prevProps","isEqual","measurements","fields","tags","omitTags","functionTags","item","FIELD_TAGS","includes","field","fieldTags","features","assign","omit","TRACING_FIELDS","combined","has","predefined","getTagList","css","hasRecentSearches","savedSearchType","SavedSearchType","EVENT","onGetTagValues","supportedTags","excludeEnvironment","dropdownClassName","React","PureComponent","withApi","withTags","WrappedComponent","createReactClass","displayName","getDisplayName","mixins","Reflux","listenTo","TagStore","getInitialState","getAllTags","onTagsUpdate","setState","render","state","MEASUREMENTS","entries","Measurements","Fragment","children","QueryField","handleFieldChange","current","fieldValue","cloneDeep","kind","FieldValueKind","TAG","MEASUREMENT","FIELD","meta","FUNCTION","function","undefined","parameters","param","i","getFieldOrTagOrMeasurementValue","defaultValue","validateColumnTypes","columnTypes","triggerChange","handleFieldParameterChange","newColumn","handleScalarParameterChange","handleRefinementChange","onChange","fieldOptions","fieldName","measurementName","tagName","indexOf","dataType","unknown","funcName","appendFieldIfUnknown","parameterDescriptions","index","fieldParameter","required","options","disabled","inFieldLabels","inputs","descriptor","placeholder","inFieldLabel","handler","inputProps","onUpdate","BufferedInput","inputMode","pattern","gridColumns","requiredInputs","BlankSpace","text","tagType","shouldRenderTag","className","takeFocus","filterPrimaryOptions","getFieldData","allFieldOptions","selectProps","autoFocus","styles","singleValue","provided","display","justifyContent","alignItems","width","option","renderParameterInputs","Container","components","Option","data","data-test-id","renderTag","SingleValue","Component","input","p","space","handleBlur","isValid","handleChange","event","target","createRef","StyledInput","ref","onBlur","validity","valid","Input","backgroundSecondary","borderRadius","gray300"],"mappings":"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","file":"AddDashboardWidgetModal~DiscoverV2Results~ProjectAlertsCreate~ProjectAlertsEdit.js","sourcesContent":["import {t} from 'app/locale';\nimport {SelectValue} from 'app/types';\nimport {measurementType, WebVital} from 'app/utils/discover/fields';\nimport theme from 'app/utils/theme';\n\nimport {Vital, VitalGroup} from './types';\n\nexport const NUM_BUCKETS = 100;\n\nexport const PERCENTILE = 0.75;\n\nexport const WEB_VITAL_DETAILS: Record<WebVital, Vital> = {\n  [WebVital.FP]: {\n    slug: 'fp',\n    name: t('First Paint'),\n    acronym: 'FP',\n    description: t(\n      'Render time of the first pixel loaded in the viewport (may overlap with FCP).'\n    ),\n    failureThreshold: 3000,\n    type: measurementType(WebVital.FP),\n  },\n  [WebVital.FCP]: {\n    slug: 'fcp',\n    name: t('First Contentful Paint'),\n    acronym: 'FCP',\n    description: t(\n      'Render time of the first image, text or other DOM node in the viewport.'\n    ),\n    failureThreshold: 3000,\n    type: measurementType(WebVital.FCP),\n  },\n  [WebVital.LCP]: {\n    slug: 'lcp',\n    name: t('Largest Contentful Paint'),\n    acronym: 'LCP',\n    description: t(\n      'Render time of the largest image, text or other DOM node in the viewport.'\n    ),\n    failureThreshold: 4000,\n    type: measurementType(WebVital.LCP),\n  },\n  [WebVital.FID]: {\n    slug: 'fid',\n    name: t('First Input Delay'),\n    acronym: 'FID',\n    description: t(\n      'Response time of the browser to a user interaction (clicking, tapping, etc).'\n    ),\n    failureThreshold: 300,\n    type: measurementType(WebVital.FID),\n  },\n  [WebVital.CLS]: {\n    slug: 'cls',\n    name: t('Cumulative Layout Shift'),\n    acronym: 'CLS',\n    description: t(\n      'Sum of layout shift scores that measure the visual stability of the page.'\n    ),\n    failureThreshold: 0.25,\n    type: measurementType(WebVital.CLS),\n  },\n  [WebVital.TTFB]: {\n    slug: 'ttfb',\n    name: t('Time to First Byte'),\n    acronym: 'TTFB',\n    description: t(\n      \"The time that it takes for a user's browser to receive the first byte of page content.\"\n    ),\n    failureThreshold: 600,\n    type: measurementType(WebVital.TTFB),\n  },\n  [WebVital.RequestTime]: {\n    slug: 'ttfb.requesttime',\n    name: t('Request Time'),\n    acronym: 'RT',\n    description: t(\n      'Captures the time spent making the request and receiving the first byte of the response.'\n    ),\n    failureThreshold: 600,\n    type: measurementType(WebVital.RequestTime),\n  },\n};\n\n// translate known short form names into their long forms\nexport const LONG_WEB_VITAL_NAMES = Object.fromEntries(\n  Object.values(WEB_VITAL_DETAILS).map(value => {\n    return [value.slug, value.name];\n  })\n);\n\nexport const WEB_VITAL_ACRONYMS = Object.fromEntries(\n  Object.values(WEB_VITAL_DETAILS).map(value => {\n    return [value.slug, value.acronym];\n  })\n);\n\nexport const FILTER_OPTIONS: SelectValue<string>[] = [\n  {label: t('Exclude Outliers'), value: 'exclude_outliers'},\n  {label: t('View All'), value: 'all'},\n];\n\n/**\n * This defines the grouping for histograms. Histograms that are in the same group\n * will be queried together on initial load for alignment. However, the zoom controls\n * are defined for each measurement independently.\n */\nconst _VITAL_GROUPS = [\n  {\n    vitals: [WebVital.FP, WebVital.FCP, WebVital.LCP],\n    min: 0,\n  },\n  {\n    vitals: [WebVital.FID],\n    min: 0,\n    precision: 2,\n  },\n  {\n    vitals: [WebVital.CLS],\n    min: 0,\n    precision: 2,\n  },\n];\n\nconst _COLORS = [\n  ...theme.charts.getColorPalette(\n    _VITAL_GROUPS.reduce((count, {vitals}) => count + vitals.length, 0) - 1\n  ),\n].reverse();\n\nexport const VITAL_GROUPS: VitalGroup[] = _VITAL_GROUPS.map(group => ({\n  ...group,\n  colors: _COLORS.splice(0, group.vitals.length),\n}));\n\nexport const ZOOM_KEYS = _VITAL_GROUPS.reduce((keys: string[], {vitals}) => {\n  vitals.forEach(vital => {\n    const vitalSlug = WEB_VITAL_DETAILS[vital].slug;\n    keys.push(`${vitalSlug}Start`);\n    keys.push(`${vitalSlug}End`);\n  });\n  return keys;\n}, []);\n","import React from 'react';\nimport {ClassNames} from '@emotion/core';\nimport assign from 'lodash/assign';\nimport flatten from 'lodash/flatten';\nimport isEqual from 'lodash/isEqual';\nimport memoize from 'lodash/memoize';\nimport omit from 'lodash/omit';\nimport PropTypes from 'prop-types';\n\nimport {fetchTagValues} from 'app/actionCreators/tags';\nimport {Client} from 'app/api';\nimport SmartSearchBar from 'app/components/smartSearchBar';\nimport {NEGATION_OPERATOR, SEARCH_WILDCARD} from 'app/constants';\nimport SentryTypes from 'app/sentryTypes';\nimport {Organization, SavedSearchType, TagCollection} from 'app/types';\nimport {defined} from 'app/utils';\nimport {\n  Field,\n  FIELD_TAGS,\n  isAggregateField,\n  isMeasurement,\n  TRACING_FIELDS,\n} from 'app/utils/discover/fields';\nimport Measurements from 'app/utils/measurements/measurements';\nimport withApi from 'app/utils/withApi';\nimport withTags from 'app/utils/withTags';\n\nconst SEARCH_SPECIAL_CHARS_REGEXP = new RegExp(\n  `^${NEGATION_OPERATOR}|\\\\${SEARCH_WILDCARD}`,\n  'g'\n);\n\ntype SearchBarProps = Omit<React.ComponentProps<typeof SmartSearchBar>, 'tags'> & {\n  api: Client;\n  organization: Organization;\n  tags: TagCollection;\n  omitTags?: string[];\n  projectIds?: number[] | Readonly<number[]>;\n  fields?: Readonly<Field[]>;\n};\n\nclass SearchBar extends React.PureComponent<SearchBarProps> {\n  static propTypes: any = {\n    api: PropTypes.object,\n    organization: SentryTypes.Organization,\n    tags: PropTypes.objectOf(SentryTypes.Tag),\n    omitTags: PropTypes.arrayOf(PropTypes.string.isRequired),\n    projectIds: PropTypes.arrayOf(PropTypes.number.isRequired),\n    fields: PropTypes.arrayOf(PropTypes.object.isRequired) as any,\n  };\n\n  componentDidMount() {\n    // Clear memoized data on mount to make tests more consistent.\n    this.getEventFieldValues.cache.clear?.();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!isEqual(this.props.projectIds, prevProps.projectIds)) {\n      // Clear memoized data when projects change.\n      this.getEventFieldValues.cache.clear?.();\n    }\n  }\n\n  /**\n   * Returns array of tag values that substring match `query`; invokes `callback`\n   * with data when ready\n   */\n  getEventFieldValues = memoize(\n    (tag, query, endpointParams): Promise<string[]> => {\n      const {api, organization, projectIds} = this.props;\n      const projectIdStrings = (projectIds as Readonly<number>[])?.map(String);\n\n      if (isAggregateField(tag.key) || isMeasurement(tag.key)) {\n        // We can't really auto suggest values for aggregate fields\n        // or measurements, so we simply don't\n        return Promise.resolve([]);\n      }\n\n      return fetchTagValues(\n        api,\n        organization.slug,\n        tag.key,\n        query,\n        projectIdStrings,\n        endpointParams,\n\n        // allows searching for tags on transactions as well\n        true\n      ).then(\n        results =>\n          flatten(results.filter(({name}) => defined(name)).map(({name}) => name)),\n        () => {\n          throw new Error('Unable to fetch event field values');\n        }\n      );\n    },\n    ({key}, query) => `${key}-${query}`\n  );\n\n  /**\n   * Prepare query string (e.g. strip special characters like negation operator)\n   */\n  prepareQuery = query => query.replace(SEARCH_SPECIAL_CHARS_REGEXP, '');\n\n  getTagList(measurements) {\n    const {fields, organization, tags, omitTags} = this.props;\n    const functionTags = fields\n      ? Object.fromEntries(\n          fields\n            .filter(item => !Object.keys(FIELD_TAGS).includes(item.field))\n            .map(item => [item.field, {key: item.field, name: item.field}])\n        )\n      : {};\n\n    const fieldTags = organization.features.includes('performance-view')\n      ? Object.assign({}, measurements, FIELD_TAGS, functionTags)\n      : omit(FIELD_TAGS, TRACING_FIELDS);\n\n    const combined = assign({}, tags, fieldTags);\n    combined.has = {\n      key: 'has',\n      name: 'Has property',\n      values: Object.keys(combined),\n      predefined: true,\n    };\n\n    return omit(combined, omitTags ?? []);\n  }\n\n  render() {\n    return (\n      <Measurements>\n        {({measurements}) => {\n          const tags = this.getTagList(measurements);\n          return (\n            <ClassNames>\n              {({css}) => (\n                <SmartSearchBar\n                  {...this.props}\n                  hasRecentSearches\n                  savedSearchType={SavedSearchType.EVENT}\n                  onGetTagValues={this.getEventFieldValues}\n                  supportedTags={tags}\n                  prepareQuery={this.prepareQuery}\n                  excludeEnvironment\n                  dropdownClassName={css`\n                    max-height: 300px;\n                    overflow-y: auto;\n                  `}\n                />\n              )}\n            </ClassNames>\n          );\n        }}\n      </Measurements>\n    );\n  }\n}\n\nexport default withApi(withTags(SearchBar));\n","import React from 'react';\nimport createReactClass from 'create-react-class';\nimport Reflux from 'reflux';\n\nimport TagStore from 'app/stores/tagStore';\nimport {TagCollection} from 'app/types';\nimport getDisplayName from 'app/utils/getDisplayName';\n\ntype InjectedTagsProps = {\n  tags: TagCollection;\n};\n\ntype State = {\n  tags: TagCollection;\n};\n\n/**\n * HOC for getting *only* tags from the TagStore.\n */\nconst withTags = <P extends InjectedTagsProps>(\n  WrappedComponent: React.ComponentType<P>\n) =>\n  createReactClass<Omit<P, keyof InjectedTagsProps>, State>({\n    displayName: `withTags(${getDisplayName(WrappedComponent)})`,\n    mixins: [Reflux.listenTo(TagStore, 'onTagsUpdate') as any],\n\n    getInitialState() {\n      return {\n        tags: TagStore.getAllTags(),\n      };\n    },\n\n    onTagsUpdate(tags: TagCollection) {\n      this.setState({\n        tags,\n      });\n    },\n\n    render() {\n      const {tags, ...props} = this.props as P;\n      return <WrappedComponent {...({tags: tags ?? this.state.tags, ...props} as P)} />;\n    },\n  });\n\nexport default withTags;\n","import React from 'react';\n\nimport {WEB_VITAL_DETAILS} from 'app/views/performance/transactionVitals/constants';\n\ntype Measurement = {\n  name: string;\n  key: string;\n};\n\ntype MeasurementCollection = {[key: string]: Measurement};\n\nconst MEASUREMENTS: MeasurementCollection = Object.fromEntries(\n  Object.entries(WEB_VITAL_DETAILS).map(([key, value]) => {\n    const newValue: Measurement = {\n      name: value.name,\n      key,\n    };\n    return [key, newValue];\n  })\n);\n\ntype ChildrenProps = {\n  measurements: MeasurementCollection;\n};\n\ntype Props = {\n  children: (props: ChildrenProps) => React.ReactNode;\n};\n\nfunction Measurements(props: Props) {\n  return (\n    <React.Fragment>\n      {props.children({\n        measurements: MEASUREMENTS,\n      })}\n    </React.Fragment>\n  );\n}\n\nexport default Measurements;\n","import React, {CSSProperties} from 'react';\n// eslint import checks can't find types in the flow code.\n// eslint-disable-next-line import/named\nimport {components, OptionProps, SingleValueProps} from 'react-select';\nimport styled from '@emotion/styled';\nimport cloneDeep from 'lodash/cloneDeep';\n\nimport SelectControl from 'app/components/forms/selectControl';\nimport Tag from 'app/components/tag';\nimport {t} from 'app/locale';\nimport space from 'app/styles/space';\nimport {SelectValue} from 'app/types';\nimport {\n  AggregateParameter,\n  ColumnType,\n  QueryFieldValue,\n  ValidateColumnTypes,\n} from 'app/utils/discover/fields';\nimport Input from 'app/views/settings/components/forms/controls/input';\n\nimport {FieldValue, FieldValueColumns, FieldValueKind} from './types';\n\ntype FieldOptions = Record<string, SelectValue<FieldValue>>;\n\n// Intermediate type that combines the current column\n// data with the AggregateParameter type.\ntype ParameterDescription =\n  | {\n      kind: 'value';\n      value: string;\n      dataType: ColumnType;\n      required: boolean;\n    }\n  | {\n      kind: 'column';\n      value: FieldValue | null;\n      options: SelectValue<FieldValue>[];\n      required: boolean;\n    };\n\ntype Props = {\n  className?: string;\n  takeFocus?: boolean;\n  fieldValue: QueryFieldValue;\n  fieldOptions: FieldOptions;\n  /**\n   * The number of columns to render. Columns that do not have a parameter will\n   * render an empty parameter placeholder. Leave blank to avoid adding spacers.\n   */\n  gridColumns?: number;\n  /**\n   * Filter the options in the primary selector. Useful if you only want to\n   * show a subset of selectable items.\n   *\n   * NOTE: This is different from passing an already filtered fieldOptions\n   * list, as tag items in the list may be used as parameters to functions.\n   */\n  filterPrimaryOptions?: (option: SelectValue<FieldValue>) => boolean;\n  /**\n   * Whether or not to add labels inside of the input fields, currently only\n   * used for the metric alert builder.\n   */\n  inFieldLabels?: boolean;\n  /**\n   * Whether or not to add the tag explaining the FieldValueKind of each field\n   */\n  shouldRenderTag?: boolean;\n  onChange: (fieldValue: QueryFieldValue) => void;\n  disabled?: boolean;\n};\n\n// Type for completing generics in react-select\ntype OptionType = {\n  label: string;\n  value: FieldValue;\n};\n\nclass QueryField extends React.Component<Props> {\n  handleFieldChange = ({value}) => {\n    const current = this.props.fieldValue;\n    let fieldValue: QueryFieldValue = cloneDeep(this.props.fieldValue);\n\n    switch (value.kind) {\n      case FieldValueKind.TAG:\n      case FieldValueKind.MEASUREMENT:\n      case FieldValueKind.FIELD:\n        fieldValue = {kind: 'field', field: value.meta.name};\n        break;\n      case FieldValueKind.FUNCTION:\n        if (current.kind === 'field') {\n          fieldValue = {kind: 'function', function: [value.meta.name, '', undefined]};\n        } else if (current.kind === 'function') {\n          fieldValue = {\n            kind: 'function',\n            function: [value.meta.name, current.function[1], current.function[2]],\n          };\n        }\n        break;\n      default:\n        throw new Error('Invalid field type found in column picker');\n    }\n\n    if (value.kind === FieldValueKind.FUNCTION) {\n      value.meta.parameters.forEach((param: AggregateParameter, i: number) => {\n        if (fieldValue.kind !== 'function') {\n          return;\n        }\n        if (param.kind === 'column') {\n          const field = this.getFieldOrTagOrMeasurementValue(fieldValue.function[i + 1]);\n          if (field === null) {\n            fieldValue.function[i + 1] = param.defaultValue || '';\n          } else if (\n            (field.kind === FieldValueKind.FIELD || field.kind === FieldValueKind.TAG) &&\n            validateColumnTypes(param.columnTypes as ValidateColumnTypes, field)\n          ) {\n            // New function accepts current field.\n            fieldValue.function[i + 1] = field.meta.name;\n          } else {\n            // field does not fit within new function requirements, use the default.\n            fieldValue.function[i + 1] = param.defaultValue || '';\n            fieldValue.function[i + 2] = undefined;\n          }\n        }\n        if (param.kind === 'value') {\n          fieldValue.function[i + 1] = param.defaultValue || '';\n        }\n      });\n\n      if (fieldValue.kind === 'function') {\n        if (value.meta.parameters.length === 0) {\n          fieldValue.function = [fieldValue.function[0], '', undefined];\n        } else if (value.meta.parameters.length === 1) {\n          fieldValue.function[2] = undefined;\n        }\n      }\n    }\n\n    this.triggerChange(fieldValue);\n  };\n\n  handleFieldParameterChange = ({value}) => {\n    const newColumn = cloneDeep(this.props.fieldValue);\n    if (newColumn.kind === 'function') {\n      newColumn.function[1] = value.meta.name;\n    }\n    this.triggerChange(newColumn);\n  };\n\n  handleScalarParameterChange = (value: string) => {\n    const newColumn = cloneDeep(this.props.fieldValue);\n    if (newColumn.kind === 'function') {\n      newColumn.function[1] = value;\n    }\n    this.triggerChange(newColumn);\n  };\n\n  handleRefinementChange = (value: string) => {\n    const newColumn = cloneDeep(this.props.fieldValue);\n    if (newColumn.kind === 'function') {\n      newColumn.function[2] = value;\n    }\n    this.triggerChange(newColumn);\n  };\n\n  triggerChange(fieldValue: QueryFieldValue) {\n    this.props.onChange(fieldValue);\n  }\n\n  getFieldOrTagOrMeasurementValue(name: string | undefined): FieldValue | null {\n    const {fieldOptions} = this.props;\n    if (name === undefined) {\n      return null;\n    }\n\n    const fieldName = `field:${name}`;\n    if (fieldOptions[fieldName]) {\n      return fieldOptions[fieldName].value;\n    }\n\n    const measurementName = `measurement:${name}`;\n    if (fieldOptions[measurementName]) {\n      return fieldOptions[measurementName].value;\n    }\n\n    const tagName =\n      name.indexOf('tags[') === 0\n        ? `tag:${name.replace(/tags\\[(.*?)\\]/, '$1')}`\n        : `tag:${name}`;\n\n    if (fieldOptions[tagName]) {\n      return fieldOptions[tagName].value;\n    }\n\n    // Likely a tag that was deleted but left behind in a saved query\n    // Cook up a tag option so select control works.\n    if (name.length > 0) {\n      return {\n        kind: FieldValueKind.TAG,\n        meta: {\n          name,\n          dataType: 'string',\n          unknown: true,\n        },\n      };\n    }\n    return null;\n  }\n\n  getFieldData() {\n    let field: FieldValue | null = null;\n\n    const {fieldValue} = this.props;\n    let {fieldOptions} = this.props;\n\n    if (fieldValue.kind === 'function') {\n      const funcName = `function:${fieldValue.function[0]}`;\n      if (fieldOptions[funcName] !== undefined) {\n        field = fieldOptions[funcName].value;\n      }\n    }\n\n    if (fieldValue.kind === 'field') {\n      field = this.getFieldOrTagOrMeasurementValue(fieldValue.field);\n      fieldOptions = this.appendFieldIfUnknown(fieldOptions, field);\n    }\n\n    let parameterDescriptions: ParameterDescription[] = [];\n    // Generate options and values for each parameter.\n    if (\n      field &&\n      field.kind === FieldValueKind.FUNCTION &&\n      field.meta.parameters.length > 0 &&\n      fieldValue.kind === FieldValueKind.FUNCTION\n    ) {\n      parameterDescriptions = field.meta.parameters.map(\n        (param, index: number): ParameterDescription => {\n          if (param.kind === 'column') {\n            const fieldParameter = this.getFieldOrTagOrMeasurementValue(\n              fieldValue.function[1]\n            );\n            fieldOptions = this.appendFieldIfUnknown(fieldOptions, fieldParameter);\n            return {\n              kind: 'column',\n              value: fieldParameter,\n              required: param.required,\n              options: Object.values(fieldOptions).filter(\n                ({value}) =>\n                  (value.kind === FieldValueKind.FIELD ||\n                    value.kind === FieldValueKind.TAG ||\n                    value.kind === FieldValueKind.MEASUREMENT) &&\n                  validateColumnTypes(param.columnTypes as ValidateColumnTypes, value)\n              ),\n            };\n          }\n\n          return {\n            kind: 'value',\n            value:\n              (fieldValue.kind === 'function' && fieldValue.function[index + 1]) ||\n              param.defaultValue ||\n              '',\n            dataType: param.dataType,\n            required: param.required,\n          };\n        }\n      );\n    }\n    return {field, fieldOptions, parameterDescriptions};\n  }\n\n  appendFieldIfUnknown(\n    fieldOptions: FieldOptions,\n    field: FieldValue | null\n  ): FieldOptions {\n    if (!field) {\n      return fieldOptions;\n    }\n\n    if (field && field.kind === FieldValueKind.TAG && field.meta.unknown) {\n      // Clone the options so we don't mutate other rows.\n      fieldOptions = Object.assign({}, fieldOptions);\n      fieldOptions[field.meta.name] = {label: field.meta.name, value: field};\n    }\n\n    return fieldOptions;\n  }\n\n  renderParameterInputs(parameters: ParameterDescription[]): React.ReactNode[] {\n    const {disabled, inFieldLabels} = this.props;\n    const inputs = parameters.map((descriptor: ParameterDescription, index: number) => {\n      if (descriptor.kind === 'column' && descriptor.options.length > 0) {\n        return (\n          <SelectControl\n            key=\"select\"\n            name=\"parameter\"\n            placeholder={t('Select value')}\n            options={descriptor.options}\n            value={descriptor.value}\n            required={descriptor.required}\n            onChange={this.handleFieldParameterChange}\n            inFieldLabel={inFieldLabels ? t('Parameter: ') : undefined}\n            disabled={disabled}\n          />\n        );\n      }\n      if (descriptor.kind === 'value') {\n        const handler =\n          index === 0 ? this.handleScalarParameterChange : this.handleRefinementChange;\n\n        const inputProps = {\n          required: descriptor.required,\n          value: descriptor.value,\n          onUpdate: handler,\n          disabled,\n        };\n        switch (descriptor.dataType) {\n          case 'number':\n            return (\n              <BufferedInput\n                name=\"refinement\"\n                key=\"parameter:number\"\n                type=\"text\"\n                inputMode=\"numeric\"\n                pattern=\"[0-9]*(\\.[0-9]*)?\"\n                {...inputProps}\n              />\n            );\n          case 'integer':\n            return (\n              <BufferedInput\n                name=\"refinement\"\n                key=\"parameter:integer\"\n                type=\"text\"\n                inputMode=\"numeric\"\n                pattern=\"[0-9]*\"\n                {...inputProps}\n              />\n            );\n          default:\n            return (\n              <BufferedInput\n                name=\"refinement\"\n                key=\"parameter:text\"\n                type=\"text\"\n                {...inputProps}\n              />\n            );\n        }\n      }\n      throw new Error(`Unknown parameter type encountered for ${this.props.fieldValue}`);\n    });\n\n    // Add enough disabled inputs to fill the grid up.\n    // We always have 1 input.\n    const {gridColumns} = this.props;\n    const requiredInputs = (gridColumns ?? inputs.length + 1) - inputs.length - 1;\n    if (gridColumns !== undefined && requiredInputs > 0) {\n      for (let i = 0; i < requiredInputs; i++) {\n        inputs.push(<BlankSpace key={i} />);\n      }\n    }\n\n    return inputs;\n  }\n\n  renderTag(kind) {\n    const {shouldRenderTag} = this.props;\n    if (shouldRenderTag === false) {\n      return null;\n    }\n    let text, tagType;\n    switch (kind) {\n      case FieldValueKind.FUNCTION:\n        text = 'f(x)';\n        tagType = 'success';\n        break;\n      case FieldValueKind.MEASUREMENT:\n        text = 'measure';\n        tagType = 'info';\n        break;\n      case FieldValueKind.TAG:\n        text = kind;\n        tagType = 'warning';\n        break;\n      case FieldValueKind.FIELD:\n        text = kind;\n        tagType = 'highlight';\n        break;\n      default:\n        text = kind;\n    }\n    return <Tag type={tagType}>{text}</Tag>;\n  }\n\n  render() {\n    const {\n      className,\n      takeFocus,\n      filterPrimaryOptions,\n      inFieldLabels,\n      disabled,\n    } = this.props;\n    const {field, fieldOptions, parameterDescriptions} = this.getFieldData();\n\n    const allFieldOptions = filterPrimaryOptions\n      ? Object.values(fieldOptions).filter(filterPrimaryOptions)\n      : Object.values(fieldOptions);\n\n    const selectProps: React.ComponentProps<SelectControl> = {\n      name: 'field',\n      options: Object.values(allFieldOptions),\n      placeholder: t('(Required)'),\n      value: field,\n      onChange: this.handleFieldChange,\n      inFieldLabel: inFieldLabels ? t('Function: ') : undefined,\n      disabled,\n    };\n    if (takeFocus && field === null) {\n      selectProps.autoFocus = true;\n    }\n\n    const styles = {\n      singleValue(provided: CSSProperties) {\n        const custom = {\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          width: 'calc(100% - 10px)',\n        };\n        return {...provided, ...custom};\n      },\n      option(provided: CSSProperties) {\n        const custom = {\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          width: '100%',\n        };\n        return {...provided, ...custom};\n      },\n    };\n\n    const parameters = this.renderParameterInputs(parameterDescriptions);\n\n    return (\n      <Container className={className} gridColumns={parameters.length + 1}>\n        <SelectControl\n          {...selectProps}\n          styles={!inFieldLabels ? styles : undefined}\n          components={{\n            Option: ({label, data, ...props}: OptionProps<OptionType>) => (\n              <components.Option label={label} {...(props as any)}>\n                <span data-test-id=\"label\">{label}</span>\n                {this.renderTag(data.value.kind)}\n              </components.Option>\n            ),\n            SingleValue: ({data, ...props}: SingleValueProps<OptionType>) => (\n              <components.SingleValue data={data} {...(props as any)}>\n                <span data-test-id=\"label\">{data.label}</span>\n                {this.renderTag(data.value.kind)}\n              </components.SingleValue>\n            ),\n          }}\n        />\n        {parameters}\n      </Container>\n    );\n  }\n}\n\nfunction validateColumnTypes(\n  columnTypes: ValidateColumnTypes,\n  input: FieldValueColumns\n): boolean {\n  if (typeof columnTypes === 'function') {\n    return columnTypes({name: input.meta.name, dataType: input.meta.dataType});\n  }\n\n  return columnTypes.includes(input.meta.dataType);\n}\n\nconst Container = styled('div')<{gridColumns: number}>`\n  display: grid;\n  grid-template-columns: repeat(${p => p.gridColumns}, 1fr);\n  grid-column-gap: ${space(1)};\n  align-items: center;\n\n  flex-grow: 1;\n`;\n\ntype InputProps = React.HTMLProps<HTMLInputElement> & {\n  onUpdate: (value: string) => void;\n  value: string;\n};\ntype InputState = {value: string};\n\n/**\n * Because controlled inputs fire onChange on every key stroke,\n * we can't update the QueryField that often as it would re-render\n * the input elements causing focus to be lost.\n *\n * Using a buffered input lets us throttle rendering and enforce data\n * constraints better.\n */\nclass BufferedInput extends React.Component<InputProps, InputState> {\n  constructor(props: InputProps) {\n    super(props);\n    this.input = React.createRef();\n  }\n\n  state = {\n    value: this.props.value,\n  };\n\n  private input: React.RefObject<HTMLInputElement>;\n\n  get isValid() {\n    if (!this.input.current) {\n      return true;\n    }\n    return this.input.current.validity.valid;\n  }\n\n  handleBlur = () => {\n    if (this.isValid) {\n      this.props.onUpdate(this.state.value);\n    } else {\n      this.setState({value: this.props.value});\n    }\n  };\n\n  handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    if (this.isValid) {\n      this.setState({value: event.target.value});\n    }\n  };\n\n  render() {\n    const {onUpdate: _, ...props} = this.props;\n    return (\n      <StyledInput\n        {...props}\n        ref={this.input}\n        className=\"form-control\"\n        value={this.state.value}\n        onChange={this.handleChange}\n        onBlur={this.handleBlur}\n      />\n    );\n  }\n}\n\n// Set a min-width to allow shrinkage in grid.\nconst StyledInput = styled(Input)`\n  /* Match the height of the select boxes */\n  height: 41px;\n  min-width: 50px;\n`;\n\nconst BlankSpace = styled('div')`\n  /* Match the height of the select boxes */\n  height: 41px;\n  min-width: 50px;\n  background: ${p => p.theme.backgroundSecondary};\n  border-radius: ${p => p.theme.borderRadius};\n  display: flex;\n  align-items: center;\n  justify-content: center;\n\n  &:after {\n    content: '${t('No parameter')}';\n    color: ${p => p.theme.gray300};\n  }\n`;\n\nexport {QueryField};\n"],"sourceRoot":""}