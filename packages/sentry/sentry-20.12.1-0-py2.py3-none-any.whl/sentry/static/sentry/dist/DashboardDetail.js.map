{"version":3,"sources":["webpack:///./app/utils/discover/charts.tsx","webpack:///./app/components/charts/errorPanel.tsx","webpack:///./app/components/charts/chartZoom.jsx","webpack:///./app/components/charts/lineChart.tsx","webpack:///./app/components/charts/transitionChart.tsx","webpack:///./app/components/charts/loadingPanel.tsx","webpack:///./app/actionCreators/events.tsx","webpack:///./app/utils/getPeriod.tsx"],"names":["tooltipFormatter","value","seriesName","aggregateOutputType","toLocaleString","formatPercentage","getDuration","toString","axisLabelFormatter","abbreviation","formatAbbreviatedNumber","axisDuration","WEEK","label","toFixed","t","DAY","HOUR","MINUTE","SECOND","ErrorPanel","p","height","getDate","date","moment","utc","format","HTML5_FMT","DATETIME_LOCAL_SECONDS","ChartZoom","props","saveCurrentPeriod","currentPeriod","period","start","end","setPeriod","saveHistory","router","onZoom","startFormatted","endFormatted","history","push","callIfFunction","zooming","updateDateTime","getUtcToLocalDateObject","handleChartReady","chart","dispatchAction","type","key","dataZoomSelectActive","onChartReady","handleZoomRestore","evt","length","onRestore","handleDataZoom","axis","getModel","option","xAxis","rangeStart","rangeEnd","previousPeriod","pop","onDataZoom","handleChartFinished","onFinished","this","disabled","children","xAxisIndex","isGroupedByDate","dataZoom","DataZoomInside","showTimeInTooltip","toolBox","ToolBox","title","zoom","back","iconStyle","borderWidth","color","opacity","React","Component","LineChart","series","seriesOptions","map","data","dataArray","options","LineSeries","name","animation","animationThreshold","animationDuration","TransitionChart","state","prevReloading","reloading","prevLoading","loading","data-test-id","Fragment","String","nextReloading","nextLoading","defaultProps","LoadingPanel","doEventsRequest","api","organization","project","environment","interval","includePrevious","query","yAxis","field","topEvents","orderby","shouldDoublePeriod","canIncludePreviousPeriod","urlQuery","Object","fromEntries","entries","filter","periodObj","getPeriod","requestPromise","slug","fetchTagFacets","orgSlug","a","urlParams","pick","values","URL_PARAM","queryOption","fetchTotalCount","then","res","count","DEFAULT_STATS_PERIOD","statsPeriod","match","periodNumber","periodLength","parseInt","Error","formattedStart","getUtcDateString","formattedEnd","diff","previousPeriodStart","subtract"],"mappings":"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","file":"DashboardDetail.js","sourcesContent":["import {t} from 'app/locale';\nimport {aggregateOutputType} from 'app/utils/discover/fields';\nimport {\n  DAY,\n  formatAbbreviatedNumber,\n  formatPercentage,\n  getDuration,\n  HOUR,\n  MINUTE,\n  SECOND,\n  WEEK,\n} from 'app/utils/formatters';\n\n/**\n * Formatter for chart tooltips that handle a variety of discover result values\n */\nexport function tooltipFormatter(value: number, seriesName: string): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 2);\n    case 'duration':\n      return getDuration(value / 1000, 2, true);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Formatter for chart axis labels that handle a variety of discover result values\n * This function is *very similar* to tooltipFormatter but outputs data with less precision.\n */\nexport function axisLabelFormatter(\n  value: number,\n  seriesName: string,\n  abbreviation: boolean = false\n): string {\n  switch (aggregateOutputType(seriesName)) {\n    case 'integer':\n    case 'number':\n      return abbreviation ? formatAbbreviatedNumber(value) : value.toLocaleString();\n    case 'percentage':\n      return formatPercentage(value, 0);\n    case 'duration':\n      return axisDuration(value);\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Specialized duration formatting for axis labels.\n * In that context we are ok sacrificing accuracy for more\n * consistent sizing.\n *\n * @param value Number of milliseconds to format.\n */\nexport function axisDuration(value: number): string {\n  if (value === 0) {\n    return '0';\n  }\n  if (value >= WEEK) {\n    const label = (value / WEEK).toFixed(0);\n    return t('%swk', label);\n  }\n  if (value >= DAY) {\n    const label = (value / DAY).toFixed(0);\n    return t('%sd', label);\n  }\n  if (value >= HOUR) {\n    const label = (value / HOUR).toFixed(0);\n    return t('%shr', label);\n  }\n  if (value >= MINUTE) {\n    const label = (value / MINUTE).toFixed(0);\n    return t('%smin', label);\n  }\n  if (value >= SECOND) {\n    const label = (value / SECOND).toFixed(0);\n    return t('%ss', label);\n  }\n  const label = (value / SECOND).toFixed(1);\n  return t('%ss', label);\n}\n","import styled from '@emotion/styled';\n\nconst ErrorPanel = styled('div')<{height?: string}>`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n\n  flex: 1;\n  flex-shrink: 0;\n  overflow: hidden;\n  height: ${p => p.height || '200px'};\n  position: relative;\n  border-color: transparent;\n  margin-bottom: 0;\n`;\n\nexport default ErrorPanel;\n","import React from 'react';\nimport moment from 'moment';\nimport PropTypes from 'prop-types';\n\nimport {updateDateTime} from 'app/actionCreators/globalSelection';\nimport DataZoomInside from 'app/components/charts/components/dataZoomInside';\nimport ToolBox from 'app/components/charts/components/toolBox';\nimport SentryTypes from 'app/sentryTypes';\nimport {callIfFunction} from 'app/utils/callIfFunction';\nimport {getUtcToLocalDateObject} from 'app/utils/dates';\n\nconst getDate = date =>\n  date ? moment.utc(date).format(moment.HTML5_FMT.DATETIME_LOCAL_SECONDS) : null;\n\n/**\n * This is a very opinionated component that takes a render prop through `children`. It\n * will provide props to be passed to `BaseChart` to enable support of zooming without\n * eCharts' clunky zoom toolboxes.\n *\n * This also is very tightly coupled with the Global Selection Header. We can make it more\n * generic if need be in the future.\n */\nclass ChartZoom extends React.Component {\n  static propTypes = {\n    router: PropTypes.object,\n    period: PropTypes.string,\n    start: PropTypes.instanceOf(Date),\n    end: PropTypes.instanceOf(Date),\n    utc: PropTypes.bool,\n    disabled: PropTypes.bool,\n\n    xAxis: SentryTypes.EChartsXAxis,\n    /**\n     * If you need the dataZoom control to control more than one chart.\n     * you can provide a list of the axis indexes.\n     */\n    xAxisIndex: PropTypes.arrayOf(PropTypes.number),\n\n    // Callback for when chart has been zoomed\n    onZoom: PropTypes.func,\n    // Callbacks for eCharts events\n    onRestore: PropTypes.func,\n    onChartReady: PropTypes.func,\n    onDataZoom: PropTypes.func,\n    onFinished: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n\n    // Zoom history\n    this.history = [];\n\n    // Initialize current period instance state for zoom history\n    this.saveCurrentPeriod(props);\n  }\n\n  componentDidUpdate() {\n    if (this.props.disabled) {\n      return;\n    }\n\n    // When component updates, make sure we sync current period state\n    // for use in zoom history\n    this.saveCurrentPeriod(this.props);\n  }\n\n  /**\n   * Save current period state from period in props to be used\n   * in handling chart's zoom history state\n   */\n  saveCurrentPeriod = props => {\n    this.currentPeriod = {\n      period: props.period,\n      start: getDate(props.start),\n      end: getDate(props.end),\n    };\n  };\n\n  /**\n   * Sets the new period due to a zoom related action\n   *\n   * Saves the current period to an instance property so that we\n   * can control URL state when zoom history is being manipulated\n   * by the chart controls.\n   *\n   * Saves a callback function to be called after chart animation is completed\n   */\n  setPeriod = ({period, start, end}, saveHistory) => {\n    const {router, onZoom} = this.props;\n    const startFormatted = getDate(start);\n    const endFormatted = getDate(end);\n\n    // Save period so that we can revert back to it when using echarts \"back\" navigation\n    if (saveHistory) {\n      this.history.push(this.currentPeriod);\n    }\n\n    // Callback to let parent component know zoom has changed\n    // This is required for some more perceived responsiveness since\n    // we delay updating URL state so that chart animation can finish\n    //\n    // Parent container can use this to change into a loading state before\n    // URL parameters are changed\n    callIfFunction(onZoom, {\n      period,\n      start: startFormatted,\n      end: endFormatted,\n    });\n\n    this.zooming = () => {\n      updateDateTime(\n        {\n          period,\n          start: startFormatted\n            ? getUtcToLocalDateObject(startFormatted)\n            : startFormatted,\n          end: endFormatted ? getUtcToLocalDateObject(endFormatted) : endFormatted,\n        },\n        router\n      );\n\n      this.saveCurrentPeriod({period, start, end});\n    };\n  };\n\n  /**\n   * Enable zoom immediately instead of having to toggle to zoom\n   */\n  handleChartReady = chart => {\n    chart.dispatchAction({\n      type: 'takeGlobalCursor',\n      key: 'dataZoomSelect',\n      dataZoomSelectActive: true,\n    });\n\n    callIfFunction(this.props.onChartReady, chart);\n  };\n\n  /**\n   * Restores the chart to initial viewport/zoom level\n   *\n   * Updates URL state to reflect initial params\n   */\n  handleZoomRestore = (evt, chart) => {\n    if (!this.history.length) {\n      return;\n    }\n\n    this.setPeriod(this.history[0]);\n\n    // reset history\n    this.history = [];\n\n    callIfFunction(this.props.onRestore, evt, chart);\n  };\n\n  handleDataZoom = (evt, chart) => {\n    const model = chart.getModel();\n    const {xAxis} = model.option;\n    const axis = xAxis[0];\n\n    // if `rangeStart` and `rangeEnd` are null, then we are going back\n    if (axis.rangeStart === null && axis.rangeEnd === null) {\n      const previousPeriod = this.history.pop();\n\n      if (!previousPeriod) {\n        return;\n      }\n\n      this.setPeriod(previousPeriod);\n    } else {\n      const start = moment.utc(axis.rangeStart);\n\n      // Add a day so we go until the end of the day (e.g. next day at midnight)\n      const end = moment.utc(axis.rangeEnd);\n\n      this.setPeriod({period: null, start, end}, true);\n    }\n\n    callIfFunction(this.props.onDataZoom, evt, chart);\n  };\n\n  /**\n   * Chart event when *any* rendering+animation finishes\n   *\n   * `this.zooming` acts as a callback function so that\n   * we can let the native zoom animation on the chart complete\n   * before we update URL state and re-render\n   */\n  handleChartFinished = () => {\n    if (typeof this.zooming === 'function') {\n      this.zooming();\n      this.zooming = null;\n    }\n    callIfFunction(this.props.onFinished);\n  };\n\n  render() {\n    const {\n      utc,\n      disabled,\n      children,\n      xAxisIndex,\n\n      onZoom: _onZoom,\n      onRestore: _onRestore,\n      onChartReady: _onChartReady,\n      onDataZoom: _onDataZoom,\n      onFinished: _onFinished,\n      ...props\n    } = this.props;\n\n    if (disabled) {\n      return children(props);\n    }\n\n    // TODO(mark) Update consumers of DataZoom when typing this.\n    const renderProps = {\n      // Zooming only works when grouped by date\n      isGroupedByDate: true,\n      onChartReady: this.handleChartReady,\n      utc,\n      dataZoom: DataZoomInside({xAxisIndex}),\n      showTimeInTooltip: true,\n      toolBox: ToolBox(\n        {},\n        {\n          dataZoom: {\n            title: {\n              zoom: '',\n              back: '',\n            },\n            iconStyle: {\n              borderWidth: 0,\n              color: 'transparent',\n              opacity: 0,\n            },\n          },\n        }\n      ),\n      onDataZoom: this.handleDataZoom,\n      onRestore: this.handleZoomRestore,\n      onFinished: this.handleChartFinished,\n      ...props,\n    };\n\n    return children(renderProps);\n  }\n}\n\nexport default ChartZoom;\n","import React from 'react';\nimport {EChartOption} from 'echarts';\n\nimport {Series} from 'app/types/echarts';\n\nimport LineSeries from './series/lineSeries';\nimport BaseChart from './baseChart';\n\ntype ChartProps = React.ComponentProps<typeof BaseChart>;\n\nexport type LineChartSeries = Series &\n  Omit<EChartOption.SeriesLine, 'data' | 'name' | 'lineStyle'> & {\n    dataArray?: EChartOption.SeriesLine['data'];\n    lineStyle?: any; // TODO(ts): Fix when echarts type is updated so that EchartOption.LineStyle matches SeriesLine['lineStyle']\n  };\n\ntype Props = Omit<ChartProps, 'series'> & {\n  series: LineChartSeries[];\n  seriesOptions?: EChartOption.SeriesLine;\n};\n\nexport default class LineChart extends React.Component<Props> {\n  render() {\n    const {series, seriesOptions, ...props} = this.props;\n\n    return (\n      <BaseChart\n        {...props}\n        series={series.map(({seriesName, data, dataArray, ...options}) =>\n          LineSeries({\n            ...seriesOptions,\n            ...options,\n            name: seriesName,\n            data: dataArray || data.map(({value, name}) => [name, value]),\n            animation: false,\n            animationThreshold: 1,\n            animationDuration: 0,\n          })\n        )}\n      />\n    );\n  }\n}\n","import React from 'react';\n\nimport LoadingPanel from 'app/components/charts/loadingPanel';\n\nconst defaultProps = {\n  height: '200px',\n};\n\ntype Props = {\n  reloading: boolean;\n  loading: boolean;\n} & typeof defaultProps;\n\ntype State = {\n  prevReloading: boolean;\n  prevLoading: boolean;\n  key: number;\n};\n\nclass TransitionChart extends React.Component<Props, State> {\n  static defaultProps = defaultProps;\n\n  state = {\n    prevReloading: this.props.reloading,\n    prevLoading: this.props.loading,\n    key: 1,\n  };\n\n  static getDerivedStateFromProps(props: Props, state: State) {\n    // Transitions are controlled using variables called:\n    // - loading and,\n    // - reloading (also called pending in other apps)\n    //\n    // This component remounts the chart to ensure the stable transition\n    // from one data set to the next.\n\n    const prevReloading = state.prevReloading;\n    const nextReloading = props.reloading;\n\n    const prevLoading = state.prevLoading;\n    const nextLoading = props.loading;\n\n    // whenever loading changes, we explicitly remount the children by updating\n    // the key prop; regardless of what state reloading is in\n    if (prevLoading !== nextLoading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key + 1,\n      };\n    }\n\n    // invariant: prevLoading === nextLoading\n\n    // if loading is true, and hasn't changed from the previous re-render,\n    // do not remount the children.\n    if (nextLoading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key,\n      };\n    }\n\n    // invariant: loading is false\n\n    // whenever the chart is transitioning from the reloading (pending) state to a non-loading state,\n    // remount the children\n    if (prevReloading && !nextReloading) {\n      return {\n        prevReloading: nextReloading,\n        prevLoading: nextLoading,\n        key: state.key + 1,\n      };\n    }\n\n    // do not remount the children in these remaining cases:\n    // !prevReloading && !nextReloading (re-render with no prop change)\n    // prevReloading && nextReloading (re-render with no prop change)\n    // !prevReloading && nextReloading (from loaded to pending state)\n\n    return {\n      prevReloading: nextReloading,\n      prevLoading: nextLoading,\n      key: state.key,\n    };\n  }\n\n  render() {\n    const {height, loading, reloading} = this.props;\n\n    if (loading && !reloading) {\n      return <LoadingPanel height={height} data-test-id=\"events-request-loading\" />;\n    }\n\n    // We make use of the key prop to explicitly remount the children\n    // https://reactjs.org/docs/lists-and-keys.html#keys\n    return (\n      <React.Fragment key={String(this.state.key)}>{this.props.children}</React.Fragment>\n    );\n  }\n}\n\nexport default TransitionChart;\n","import React from 'react';\nimport styled from '@emotion/styled';\n\nimport LoadingMask from 'app/components/loadingMask';\n\ntype Props = {\n  height?: string;\n} & React.HTMLProps<HTMLDivElement>;\n\nconst LoadingPanel = styled(({height: _height, ...props}: Props) => (\n  <div {...props}>\n    <LoadingMask />\n  </div>\n))`\n  flex: 1;\n  flex-shrink: 0;\n  overflow: hidden;\n  height: ${p => p.height};\n  position: relative;\n  border-color: transparent;\n  margin-bottom: 0;\n`;\n\nLoadingPanel.defaultProps = {\n  height: '200px',\n};\n\nexport default LoadingPanel;\n","import {LocationDescriptor} from 'history';\nimport pick from 'lodash/pick';\n\nimport {Client} from 'app/api';\nimport {canIncludePreviousPeriod} from 'app/components/charts/utils';\nimport {URL_PARAM} from 'app/constants/globalSelectionHeader';\nimport {\n  DateString,\n  EventsStats,\n  MultiSeriesEventsStats,\n  OrganizationSummary,\n} from 'app/types';\nimport {LocationQuery} from 'app/utils/discover/eventView';\nimport {getPeriod} from 'app/utils/getPeriod';\n\ntype Options = {\n  organization: OrganizationSummary;\n  project?: number[];\n  environment?: string[];\n  period?: string;\n  start?: DateString;\n  end?: DateString;\n  interval?: string;\n  includePrevious?: boolean;\n  limit?: number;\n  query?: string;\n  yAxis?: string | string[];\n  field?: string[];\n  topEvents?: number;\n  orderby?: string;\n};\n\n/**\n * Make requests to `events-stats` endpoint\n *\n * @param {Object} api API client instance\n * @param {Object} options Request parameters\n * @param {Object} options.organization Organization object\n * @param {Number[]} options.project List of project ids\n * @param {String[]} options.environment List of environments to query for\n * @param {String} options.period Time period to query for, in the format: <integer><units> where units are \"d\" or \"h\"\n * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are \"d\", \"h\", \"m\", \"s\"\n * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?\n * @param {Number} options.limit The number of rows to return\n * @param {String} options.query Search query\n */\nexport const doEventsRequest = (\n  api: Client,\n  {\n    organization,\n    project,\n    environment,\n    period,\n    start,\n    end,\n    interval,\n    includePrevious,\n    query,\n    yAxis,\n    field,\n    topEvents,\n    orderby,\n  }: Options\n): Promise<EventsStats | MultiSeriesEventsStats> => {\n  const shouldDoublePeriod = canIncludePreviousPeriod(includePrevious, period);\n  const urlQuery = Object.fromEntries(\n    Object.entries({\n      interval,\n      project,\n      environment,\n      query,\n      yAxis,\n      field,\n      topEvents,\n      orderby,\n    }).filter(([, value]) => typeof value !== 'undefined')\n  );\n\n  // Doubling period for absolute dates is not accurate unless starting and\n  // ending times are the same (at least for daily intervals). This is\n  // the tradeoff for now.\n  const periodObj = getPeriod({period, start, end}, {shouldDoublePeriod});\n\n  return api.requestPromise(`/organizations/${organization.slug}/events-stats/`, {\n    query: {\n      ...urlQuery,\n      ...periodObj,\n    },\n  });\n};\n\nexport type EventQuery = {\n  field: string[];\n  project?: string | string[];\n  sort?: string | string[];\n  query: string;\n  per_page?: number;\n  referrer?: string;\n  environment?: string[];\n  noPagination?: boolean;\n};\n\nexport type TagSegment = {\n  count: number;\n  name: string;\n  value: string;\n  url: LocationDescriptor;\n  isOther?: boolean;\n  key?: string;\n};\n\nexport type Tag = {\n  key: string;\n  topValues: Array<TagSegment>;\n};\n\n/**\n * Fetches tag facets for a query\n */\nexport async function fetchTagFacets(\n  api: Client,\n  orgSlug: string,\n  query: EventQuery\n): Promise<Tag[]> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  return api.requestPromise(`/organizations/${orgSlug}/events-facets/`, {\n    query: queryOption,\n  });\n}\n\n/**\n * Fetches total count of events for a given query\n */\nexport async function fetchTotalCount(\n  api: Client,\n  orgSlug: String,\n  query: EventQuery & LocationQuery\n): Promise<number> {\n  const urlParams = pick(query, Object.values(URL_PARAM));\n\n  const queryOption = {...urlParams, query: query.query};\n\n  type Response = {\n    count: number;\n  };\n\n  return api\n    .requestPromise(`/organizations/${orgSlug}/events-meta/`, {\n      query: queryOption,\n    })\n    .then((res: Response) => res.count);\n}\n","import moment from 'moment';\n\nimport {DEFAULT_STATS_PERIOD} from 'app/constants';\nimport {getUtcDateString} from 'app/utils/dates';\n\n/**\n * Gets the period to query with if we need to double the initial period in order\n * to get data for the previous period\n *\n * @param {Object} dateObj The date object\n * @param {String} dateObj.period Relative period string in format \"<int><unit>\" (e.g. 4d for 4 days)\n * @param {Date} dateObj.start Starting date object\n * @param {Date} dateObj.end Ending date object\n * @param {Object} options Options\n * @param {Boolean} [options.shouldDoublePeriod] Doubles the given period (useful for getting previous period data)\n * @return {Object} Returns an object with either a period or start/end dates ({statsPeriod: string} or {start: string, end: string})\n */\ntype Options = {shouldDoublePeriod?: boolean};\n\nexport const getPeriod = (\n  {period, start, end},\n  {shouldDoublePeriod}: Options = {}\n): {start: string; end: string} | {statsPeriod: string} => {\n  if (!period && !start && !end) {\n    period = DEFAULT_STATS_PERIOD;\n  }\n\n  // you can not specify both relative and absolute periods\n  // relative period takes precedence\n  if (period) {\n    if (!shouldDoublePeriod) {\n      return {statsPeriod: period};\n    }\n    const [, periodNumber, periodLength] = period.match(/([0-9]+)([mhdw])/);\n\n    return {statsPeriod: `${parseInt(periodNumber, 10) * 2}${periodLength}`};\n  }\n\n  if (!start || !end) {\n    throw new Error('start and end required');\n  }\n\n  const formattedStart = getUtcDateString(start);\n  const formattedEnd = getUtcDateString(end);\n\n  if (shouldDoublePeriod) {\n    // get duration of end - start and double\n    const diff = moment(end).diff(moment(start));\n\n    const previousPeriodStart = moment(start).subtract(diff);\n\n    // This is not as accurate as having 2 start/end objs\n    return {\n      start: getUtcDateString(previousPeriodStart),\n      end: formattedEnd,\n    };\n  }\n\n  return {\n    start: formattedStart,\n    end: formattedEnd,\n  };\n};\n"],"sourceRoot":""}