{"version":3,"sources":["webpack:///./app/views/settings/components/forms/form.tsx","webpack:///./app/views/settings/components/forms/model.tsx","webpack:////workspace/node_modules/@babel/runtime/helpers/initializerDefineProperty.js","webpack:////workspace/node_modules/@babel/runtime/helpers/initializerWarningHelper.js"],"names":["Form","props","context","model","FormModel","onSubmit","e","preventDefault","isSaving","onPreSubmit","getData","onSubmitSuccess","onSubmitError","saveForm","data","submitSuccess","error","submitError","saveOnBlur","apiEndpoint","apiMethod","resetOnError","onFieldChange","initialData","allowUndo","setInitialData","setFormOptions","this","form","reset","className","children","footerClass","footerStyle","submitDisabled","submitLabel","submitPriority","cancelLabel","onCancel","extraButton","requireChanges","hideFooter","shouldShowFooter","data-test-id","isRenderFunc","StyledFooter","style","DefaultButtons","type","disabled","onClick","marginLeft","priority","isError","formChanged","React","Component","childContextTypes","PropTypes","bool","isRequired","object","defaultProps","t","p","Panel","space","options","fields","observable","map","fieldDescriptor","Map","snapshots","api","formErrors","Client","clear","resetForm","errors","fieldState","replace","toJSON","entries","id","set","defaultValue","setValue","snapshot","unshift","key","descriptor","has","get","transformer","getValue","value","Object","keys","getTransformedValue","reduce","acc","getDescriptor","defined","getError","length","endpoint","method","Promise","resolve","reject","request","success","response","quiet","finalValue","transformInput","validateField","updateShowSaveState","updateShowReturnButtonState","validate","fieldIsRequiredMessage","isValidRequiredField","push","forEach","field","errorMessage","setError","isValueChanged","saveOnBlurFieldOverride","getFieldState","setFieldState","shift","validateForm","saveSnapshot","createSnapshot","doApiRequest","getTransformedData","setFormSaving","then","resp","currentValue","oldValue","savePromise","saveFieldRequest","newValue","change","old","new","saveOnBlurUndoMessage","initialValue","isValidField","setSaving","a","responseJSON","nonFieldErrors","non_field_errors","Array","isArray","addErrorMessage","duration","console","saveField","formState","FormState","SAVING","state","READY","ERROR","from","err","mapFormErrors","handleErrorResponse","isEqual","size","computed","action","module","exports","target","property","defineProperty","enumerable","configurable","writable","initializer","call","Error"],"mappings":"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","file":"AcceptProjectTransfer~AccountDetails~AccountEmails~AccountNotifications~AccountNotificationsFineTuni~42840529.js","sourcesContent":["import React from 'react';\nimport styled from '@emotion/styled';\nimport {Observer} from 'mobx-react';\nimport PropTypes from 'prop-types';\n\nimport {APIRequestMethod} from 'app/api';\nimport Button from 'app/components/button';\nimport Panel from 'app/components/panels/panel';\nimport {t} from 'app/locale';\nimport space from 'app/styles/space';\nimport {isRenderFunc} from 'app/utils/isRenderFunc';\nimport FormModel, {FormOptions} from 'app/views/settings/components/forms/model';\n\ntype Data = Record<string, any>;\n\ntype RenderProps = {\n  model: FormModel;\n};\n\ntype RenderFunc = (props: RenderProps) => React.ReactNode;\n\ntype Props = {\n  apiMethod?: APIRequestMethod;\n  apiEndpoint?: string;\n  children?: React.ReactNode | RenderFunc;\n  className?: string;\n  cancelLabel?: string;\n  submitDisabled?: boolean;\n  submitLabel?: string;\n  submitPriority?: React.ComponentProps<typeof Button>['priority'];\n  footerClass?: string;\n  footerStyle?: React.CSSProperties;\n  extraButton?: React.ReactNode;\n  initialData?: Data;\n  // Require changes before able to submit form\n  requireChanges?: boolean;\n  // Reset form when there are errors; after submit\n  resetOnError?: boolean;\n  hideFooter?: boolean;\n  allowUndo?: boolean;\n  // Save field on control blur\n  saveOnBlur?: boolean;\n  model?: FormModel;\n  'data-test-id'?: string;\n\n  onCancel?: (e: React.MouseEvent) => void;\n  onSubmit?: (\n    data: Data,\n    onSubmitSuccess: (data: Data) => void,\n    onSubmitError: (error: any) => void,\n    e: React.FormEvent,\n    model: FormModel\n  ) => void;\n  onPreSubmit?: () => void;\n} & Pick<FormOptions, 'onSubmitSuccess' | 'onSubmitError' | 'onFieldChange'>;\n\ntype Context = {\n  saveOnBlur: boolean;\n  form: FormModel;\n};\n\nexport default class Form extends React.Component<Props> {\n  static propTypes: any = {\n    cancelLabel: PropTypes.string,\n    onCancel: PropTypes.func,\n    onSubmit: PropTypes.func,\n    onSubmitSuccess: PropTypes.func,\n    onSubmitError: PropTypes.func,\n    onFieldChange: PropTypes.func,\n    submitDisabled: PropTypes.bool,\n    submitLabel: PropTypes.string,\n    submitPriority: PropTypes.string,\n    footerClass: PropTypes.string,\n    footerStyle: PropTypes.object,\n    extraButton: PropTypes.element,\n    initialData: PropTypes.object,\n    // Require changes before able to submit form\n    requireChanges: PropTypes.bool,\n    // Reset form when there are errors, after submit\n    resetOnError: PropTypes.bool,\n    hideFooter: PropTypes.bool,\n    allowUndo: PropTypes.bool,\n    // Save field on control blur\n    saveOnBlur: PropTypes.bool,\n    model: PropTypes.object,\n    apiMethod: PropTypes.string,\n    apiEndpoint: PropTypes.string,\n    'data-test-id': PropTypes.string,\n  };\n\n  static childContextTypes = {\n    saveOnBlur: PropTypes.bool.isRequired,\n    form: PropTypes.object.isRequired,\n  };\n\n  static defaultProps = {\n    cancelLabel: t('Cancel'),\n    submitLabel: t('Save Changes'),\n    submitDisabled: false,\n    submitPriority: 'primary' as 'primary',\n    className: 'form-stacked',\n    requireChanges: false,\n    allowUndo: false,\n    saveOnBlur: false,\n  };\n\n  constructor(props: Props, context: Context) {\n    super(props, context);\n    const {\n      saveOnBlur,\n      apiEndpoint,\n      apiMethod,\n      resetOnError,\n      onSubmitSuccess,\n      onSubmitError,\n      onFieldChange,\n      initialData,\n      allowUndo,\n    } = props;\n\n    this.model.setInitialData(initialData);\n    this.model.setFormOptions({\n      resetOnError,\n      allowUndo,\n      onFieldChange,\n      onSubmitSuccess,\n      onSubmitError,\n      saveOnBlur,\n      apiEndpoint,\n      apiMethod,\n    });\n  }\n\n  getChildContext() {\n    return {\n      saveOnBlur: this.props.saveOnBlur,\n      form: this.model,\n    };\n  }\n\n  componentWillUnmount() {\n    this.model.reset();\n  }\n\n  model: FormModel = this.props.model || new FormModel();\n\n  onSubmit = e => {\n    e.preventDefault();\n    if (this.model.isSaving) {\n      return;\n    }\n\n    this.props.onPreSubmit?.();\n\n    if (this.props.onSubmit) {\n      this.props.onSubmit(\n        this.model.getData(),\n        this.onSubmitSuccess,\n        this.onSubmitError,\n        e,\n        this.model\n      );\n    } else {\n      this.model.saveForm();\n    }\n  };\n\n  onSubmitSuccess = data => {\n    const {onSubmitSuccess} = this.props;\n    this.model.submitSuccess(data);\n\n    if (onSubmitSuccess) {\n      onSubmitSuccess(data, this.model);\n    }\n  };\n\n  onSubmitError = error => {\n    const {onSubmitError} = this.props;\n    this.model.submitError(error);\n\n    if (onSubmitError) {\n      onSubmitError(error, this.model);\n    }\n  };\n\n  render() {\n    const {\n      className,\n      children,\n      footerClass,\n      footerStyle,\n      submitDisabled,\n      submitLabel,\n      submitPriority,\n      cancelLabel,\n      onCancel,\n      extraButton,\n      requireChanges,\n      saveOnBlur,\n      hideFooter,\n    } = this.props;\n    const shouldShowFooter =\n      typeof hideFooter !== 'undefined' ? !hideFooter : !saveOnBlur;\n\n    return (\n      <form\n        onSubmit={this.onSubmit}\n        className={className}\n        data-test-id={this.props['data-test-id']}\n      >\n        <div>\n          {isRenderFunc<RenderFunc>(children) ? children({model: this.model}) : children}\n        </div>\n\n        {shouldShowFooter && (\n          <StyledFooter\n            className={footerClass}\n            style={footerStyle}\n            saveOnBlur={saveOnBlur}\n          >\n            {extraButton}\n            <DefaultButtons>\n              {onCancel && (\n                <Observer>\n                  {() => (\n                    <Button\n                      type=\"button\"\n                      disabled={this.model.isSaving}\n                      onClick={onCancel}\n                      style={{marginLeft: 5}}\n                    >\n                      {cancelLabel}\n                    </Button>\n                  )}\n                </Observer>\n              )}\n\n              <Observer>\n                {() => (\n                  <Button\n                    data-test-id=\"form-submit\"\n                    priority={submitPriority}\n                    disabled={\n                      this.model.isError ||\n                      this.model.isSaving ||\n                      submitDisabled ||\n                      (requireChanges ? !this.model.formChanged : false)\n                    }\n                    type=\"submit\"\n                  >\n                    {submitLabel}\n                  </Button>\n                )}\n              </Observer>\n            </DefaultButtons>\n          </StyledFooter>\n        )}\n      </form>\n    );\n  }\n}\n\nconst StyledFooter = styled('div')<{saveOnBlur?: boolean}>`\n  display: flex;\n  justify-content: flex-end;\n  margin-top: 25px;\n  border-top: 1px solid #e9ebec;\n  background: none;\n  padding: 16px 0 0;\n  margin-bottom: 16px;\n\n  ${p =>\n    !p.saveOnBlur &&\n    `\n  ${Panel} & {\n    margin-top: 0;\n    padding-right: 36px;\n  }\n\n  /* Better padding with form inside of a modal */\n  .modal-content & {\n    padding-right: 30px;\n    margin-left: -30px;\n    margin-right: -30px;\n    margin-bottom: -30px;\n    margin-top: 16px;\n    padding-bottom: 16px;\n  }\n  `};\n`;\n\nconst DefaultButtons = styled('div')`\n  display: grid;\n  grid-gap: ${space(1)};\n  grid-auto-flow: column;\n  justify-content: flex-end;\n  flex: 1;\n`;\n","import isEqual from 'lodash/isEqual';\nimport {action, computed, observable, ObservableMap} from 'mobx';\n\nimport {addErrorMessage, saveOnBlurUndoMessage} from 'app/actionCreators/indicator';\nimport {APIRequestMethod, Client} from 'app/api';\nimport FormState from 'app/components/forms/state';\nimport {t} from 'app/locale';\nimport {defined} from 'app/utils';\n\ntype Snapshot = Map<string, FieldValue>;\ntype SaveSnapshot = (() => number) | null;\n\nexport type FieldValue = string | number | boolean | undefined; //is undefined valid here?\n\nexport type FormOptions = {\n  apiEndpoint?: string;\n  apiMethod?: APIRequestMethod;\n  allowUndo?: boolean;\n  resetOnError?: boolean;\n  saveOnBlur?: boolean;\n  onFieldChange?: (id: string, finalValue: FieldValue) => void;\n  onSubmitSuccess?: (\n    response: any,\n    instance: FormModel,\n    id?: string,\n    change?: {old: FieldValue; new: FieldValue}\n  ) => void;\n  onSubmitError?: (error: any, instance: FormModel, id?: string) => void;\n};\n\ntype OptionsWithInitial = FormOptions & {initialData?: object};\n\nclass FormModel {\n  /**\n   * Map of field name -> value\n   */\n  fields: ObservableMap<string, FieldValue> = observable.map();\n\n  /**\n   * Errors for individual fields\n   * Note we don't keep error in `this.fieldState` so that we can easily\n   * See if the form is in an \"error\" state with the `isError` getter\n   */\n  @observable errors = new Map();\n\n  /**\n   * State of individual fields\n   *\n   * Map of field name -> object\n   */\n  @observable fieldState = new Map();\n\n  /**\n   * State of the form as a whole\n   */\n  @observable formState;\n\n  /**\n   * Holds field properties as declared in <Form>\n   * Does not need to be observable since these props should never change\n   */\n  fieldDescriptor = new Map();\n\n  /**\n   * Holds a list of `fields` states\n   */\n  snapshots: Array<Snapshot> = [];\n\n  /**\n   * POJO of field name -> value\n   * It holds field values \"since last save\"\n   */\n  initialData = {};\n\n  api: Client;\n\n  formErrors: any;\n\n  options: FormOptions;\n\n  constructor({initialData, ...options}: OptionsWithInitial = {}) {\n    this.options = options || {};\n    if (initialData) {\n      this.setInitialData(initialData);\n    }\n\n    this.api = new Client();\n  }\n\n  /**\n   * Reset state of model\n   */\n  reset() {\n    this.api.clear();\n    this.fieldDescriptor.clear();\n    this.resetForm();\n  }\n\n  resetForm() {\n    this.fields.clear();\n    this.errors.clear();\n    this.fieldState.clear();\n    this.snapshots = [];\n    this.initialData = {};\n  }\n\n  /**\n   * Deep equality comparison between last saved state and current fields state\n   */\n  @computed\n  get formChanged() {\n    return !isEqual(this.initialData, this.fields.toJSON());\n  }\n\n  @computed\n  get formData() {\n    return this.fields;\n  }\n\n  /** Is form saving */\n  @computed\n  get isSaving() {\n    return this.formState === FormState.SAVING;\n  }\n\n  /** Does form have any errors */\n  @computed\n  get isError() {\n    return !!this.errors.size;\n  }\n\n  /**\n   * Sets initial form data\n   *\n   * Also resets snapshots\n   */\n  setInitialData(initialData?: object) {\n    this.fields.replace(initialData || {});\n    this.initialData = this.fields.toJSON() || {};\n\n    this.snapshots = [new Map(this.fields.entries())];\n  }\n\n  /**\n   * Set form options\n   */\n  setFormOptions(options: FormOptions) {\n    this.options = options || {};\n  }\n\n  /**\n   * Set field properties\n   */\n  setFieldDescriptor(id: string, props) {\n    //TODO(TS): add type to props\n    this.fieldDescriptor.set(id, props);\n\n    // Set default value iff initialData for field is undefined\n    // This must take place before checking for `props.setValue` so that it can\n    // be applied to `defaultValue`\n    if (\n      typeof props.defaultValue !== 'undefined' &&\n      typeof this.initialData[id] === 'undefined'\n    ) {\n      this.initialData[id] =\n        typeof props.defaultValue === 'function'\n          ? props.defaultValue()\n          : props.defaultValue;\n\n      this.fields.set(id, this.initialData[id]);\n    }\n\n    if (typeof props.setValue === 'function') {\n      this.initialData[id] = props.setValue(this.initialData[id], props);\n      this.fields.set(id, this.initialData[id]);\n    }\n  }\n\n  /**\n   * Remove a field from the descriptor map and errors.\n   */\n  removeField(id: string) {\n    this.fieldDescriptor.delete(id);\n    this.errors.delete(id);\n  }\n\n  /**\n   * Creates a cloned Map of `this.fields` and returns a closure that when called\n   * will save Map to `snapshots\n   */\n  createSnapshot() {\n    const snapshot = new Map(this.fields.entries());\n    return () => this.snapshots.unshift(snapshot);\n  }\n\n  getDescriptor(id: string, key: string) {\n    // Needs to call `has` or else component will not be reactive if `id` doesn't exist in observable map\n    const descriptor = this.fieldDescriptor.has(id) && this.fieldDescriptor.get(id);\n    if (!descriptor) {\n      return null;\n    }\n\n    return descriptor[key];\n  }\n\n  getFieldState(id: string, key: string) {\n    // Needs to call `has` or else component will not be reactive if `id` doesn't exist in observable map\n    const fieldState = this.fieldState.has(id) && this.fieldState.get(id);\n    if (!fieldState) {\n      return null;\n    }\n\n    return fieldState[key];\n  }\n\n  getValue(id: string) {\n    if (!this.fields.has(id)) {\n      return '';\n    }\n\n    return this.fields.get(id);\n  }\n\n  getTransformedValue(id: string) {\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n    const transformer =\n      fieldDescriptor && typeof fieldDescriptor.getValue === 'function'\n        ? fieldDescriptor.getValue\n        : null;\n    const value = this.getValue(id);\n\n    return transformer ? transformer(value) : value;\n  }\n\n  /**\n   * Data represented in UI\n   */\n  getData() {\n    return this.fields.toJSON();\n  }\n\n  /**\n   * Form data that will be sent to API endpoint (i.e. after transforms)\n   */\n  getTransformedData() {\n    const form = this.getData();\n\n    return Object.keys(form)\n      .map(id => [id, this.getTransformedValue(id)])\n      .reduce((acc, [id, value]) => {\n        acc[id] = value;\n        return acc;\n      }, {});\n  }\n\n  getError(id: string) {\n    return this.errors.has(id) && this.errors.get(id);\n  }\n\n  // Returns true if not required or is required and is not empty\n  isValidRequiredField(id: string) {\n    // Check field descriptor to see if field is required\n    const isRequired = this.getDescriptor(id, 'required');\n    const value = this.getValue(id);\n    return !isRequired || (value !== '' && defined(value));\n  }\n\n  isValidField(id: string) {\n    return (this.getError(id) || []).length === 0;\n  }\n\n  doApiRequest({\n    apiEndpoint,\n    apiMethod,\n    data,\n  }: {\n    apiEndpoint?: string;\n    apiMethod?: APIRequestMethod;\n    data: object;\n  }) {\n    const endpoint = apiEndpoint || this.options.apiEndpoint || '';\n    const method = apiMethod || this.options.apiMethod;\n\n    return new Promise((resolve, reject) =>\n      this.api.request(endpoint, {\n        method,\n        data,\n        success: response => resolve(response),\n        error: error => reject(error),\n      })\n    );\n  }\n\n  /**\n   * Set the value of the form field\n   * if quiet is true, we skip callbacks, validations\n   */\n  @action\n  setValue(id: string, value: FieldValue, {quiet}: {quiet?: boolean} = {}) {\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n    let finalValue = value;\n\n    if (fieldDescriptor && typeof fieldDescriptor.transformInput === 'function') {\n      finalValue = fieldDescriptor.transformInput(value);\n    }\n\n    this.fields.set(id, finalValue);\n    if (quiet) {\n      return;\n    }\n\n    if (this.options.onFieldChange) {\n      this.options.onFieldChange(id, finalValue);\n    }\n\n    this.validateField(id);\n    this.updateShowSaveState(id, finalValue);\n    this.updateShowReturnButtonState(id, finalValue);\n  }\n\n  @action\n  validateField(id: string) {\n    const validate = this.getDescriptor(id, 'validate');\n    let errors: any[] = [];\n\n    if (typeof validate === 'function') {\n      // Returns \"tuples\" of [id, error string]\n      errors = validate({model: this, id, form: this.getData()}) || [];\n    }\n\n    const fieldIsRequiredMessage = t('Field is required');\n\n    if (!this.isValidRequiredField(id)) {\n      errors.push([id, fieldIsRequiredMessage]);\n    }\n\n    // If we have no errors, ensure we clear the field\n    errors = errors.length === 0 ? [[id, null]] : errors;\n\n    errors.forEach(([field, errorMessage]) => this.setError(field, errorMessage));\n    return undefined;\n  }\n\n  @action\n  updateShowSaveState(id: string, value: FieldValue) {\n    const isValueChanged = value !== this.initialData[id];\n    // Update field state to \"show save\" if save on blur is disabled for this field\n    // (only if contents of field differs from initial value)\n    const saveOnBlurFieldOverride = this.getDescriptor(id, 'saveOnBlur');\n    if (typeof saveOnBlurFieldOverride === 'undefined' || saveOnBlurFieldOverride) {\n      return;\n    }\n    if (this.getFieldState(id, 'showSave') === isValueChanged) {\n      return;\n    }\n\n    this.setFieldState(id, 'showSave', isValueChanged);\n  }\n\n  @action\n  updateShowReturnButtonState(id: string, value: FieldValue) {\n    const isValueChanged = value !== this.initialData[id];\n    const shouldShowReturnButton = this.getDescriptor(id, 'showReturnButton');\n\n    if (!shouldShowReturnButton) {\n      return;\n    }\n    // Only update state if state has changed\n    if (this.getFieldState(id, 'showReturnButton') === isValueChanged) {\n      return;\n    }\n\n    this.setFieldState(id, 'showReturnButton', isValueChanged);\n  }\n\n  /**\n   * Changes form values to previous saved state\n   */\n  @action\n  undo() {\n    // Always have initial data snapshot\n    if (this.snapshots.length < 2) {\n      return null;\n    }\n\n    this.snapshots.shift();\n    this.fields.replace(this.snapshots[0]);\n\n    return true;\n  }\n\n  /**\n   * Attempts to save entire form to server and saves a snapshot for undos\n   */\n  @action\n  saveForm() {\n    if (!this.validateForm()) {\n      return null;\n    }\n\n    let saveSnapshot: SaveSnapshot = this.createSnapshot();\n\n    const request = this.doApiRequest({\n      data: this.getTransformedData(),\n    });\n\n    this.setFormSaving();\n    request\n      .then(resp => {\n        // save snapshot\n        if (saveSnapshot) {\n          saveSnapshot();\n          saveSnapshot = null;\n        }\n\n        if (this.options.onSubmitSuccess) {\n          this.options.onSubmitSuccess(resp, this);\n        }\n      })\n      .catch(resp => {\n        // should we revert field value to last known state?\n        saveSnapshot = null;\n        if (this.options.resetOnError) {\n          this.setInitialData({});\n        }\n        this.submitError(resp);\n        if (this.options.onSubmitError) {\n          this.options.onSubmitError(resp, this);\n        }\n      });\n\n    return request;\n  }\n\n  /**\n   * Attempts to save field and show undo message if necessary.\n   * Calls submit handlers.\n   * TODO(billy): This should return a promise that resolves (instead of null)\n   */\n  @action\n  saveField(id: string, currentValue: FieldValue) {\n    const oldValue = this.initialData[id];\n    const savePromise = this.saveFieldRequest(id, currentValue);\n\n    if (!savePromise) {\n      return null;\n    }\n\n    return savePromise\n      .then(resp => {\n        const newValue = this.getValue(id);\n        const change = {old: oldValue, new: newValue};\n\n        // Only use `allowUndo` option if explicitly defined\n        if (typeof this.options.allowUndo === 'undefined' || this.options.allowUndo) {\n          saveOnBlurUndoMessage(change, this, id);\n        }\n\n        if (this.options.onSubmitSuccess) {\n          this.options.onSubmitSuccess(resp, this, id, change);\n        }\n\n        return resp;\n      })\n      .catch(error => {\n        if (this.options.onSubmitError) {\n          this.options.onSubmitError(error, this, id);\n        }\n        return {};\n      });\n  }\n\n  /**\n   * Saves a field with new value\n   *\n   * If field has changes, field does not have errors, then it will:\n   * Save a snapshot, apply any data transforms, perform api request.\n   *\n   * If successful then: 1) reset save state, 2) update `initialData`, 3) save snapshot\n   * If failed then: 1) reset save state, 2) add error state\n   */\n  @action\n  saveFieldRequest(id: string, currentValue: FieldValue) {\n    const initialValue = this.initialData[id];\n\n    // Don't save if field hasn't changed\n    // Don't need to check for error state since initialData wouldn't have updated since last error\n    if (\n      currentValue === initialValue ||\n      (currentValue === '' && !defined(initialValue))\n    ) {\n      return null;\n    }\n\n    // Check for error first\n    this.validateField(id);\n    if (!this.isValidField(id)) {\n      return null;\n    }\n\n    // shallow clone fields\n    let saveSnapshot: SaveSnapshot = this.createSnapshot();\n\n    // Save field + value\n    this.setSaving(id, true);\n\n    const fieldDescriptor = this.fieldDescriptor.get(id);\n\n    // Check if field needs to handle transforming request object\n    const getData =\n      typeof fieldDescriptor.getData === 'function' ? fieldDescriptor.getData : a => a;\n\n    const request = this.doApiRequest({\n      data: getData(\n        {[id]: this.getTransformedValue(id)},\n        {model: this, id, form: this.getData()}\n      ),\n    });\n\n    request\n      .then(data => {\n        this.setSaving(id, false);\n\n        // save snapshot\n        if (saveSnapshot) {\n          saveSnapshot();\n          saveSnapshot = null;\n        }\n\n        // Update initialData after successfully saving a field as it will now be the baseline value\n        this.initialData[id] = this.getValue(id);\n\n        return data;\n      })\n      .catch(resp => {\n        // should we revert field value to last known state?\n        saveSnapshot = null;\n\n        // Field can be configured to reset on error\n        // e.g. BooleanFields\n        const shouldReset = this.getDescriptor(id, 'resetOnError');\n        if (shouldReset) {\n          this.setValue(id, initialValue);\n        }\n\n        // API can return a JSON object with either:\n        // 1) map of {[fieldName] => Array<ErrorMessages>}\n        // 2) {'non_field_errors' => Array<ErrorMessages>}\n        if (resp && resp.responseJSON) {\n          //non-field errors can be camelcase or snake case\n          const nonFieldErrors =\n            resp.responseJSON.non_field_errors || resp.responseJSON.nonFieldErrors;\n\n          // Show resp msg from API endpoint if possible\n          if (Array.isArray(resp.responseJSON[id]) && resp.responseJSON[id].length) {\n            // Just take first resp for now\n            this.setError(id, resp.responseJSON[id][0]);\n          } else if (Array.isArray(nonFieldErrors) && nonFieldErrors.length) {\n            addErrorMessage(nonFieldErrors[0], {duration: 10000});\n            // Reset saving state\n            this.setError(id, '');\n          } else {\n            this.setError(id, 'Failed to save');\n          }\n        } else {\n          // Default error behavior\n          this.setError(id, 'Failed to save');\n        }\n\n        // eslint-disable-next-line no-console\n        console.error('Error saving form field', resp && resp.responseJSON);\n      });\n\n    return request;\n  }\n\n  /**\n   * This is called when a field is blurred\n   *\n   * If `saveOnBlur` is set then call `saveField` and handle form callbacks accordingly\n   */\n  @action\n  handleBlurField(id: string, currentValue: FieldValue) {\n    // Nothing to do if `saveOnBlur` is not on\n    if (!this.options.saveOnBlur) {\n      return null;\n    }\n\n    // Fields can individually set `saveOnBlur` to `false` (note this is ignored when `undefined`)\n    const saveOnBlurFieldOverride = this.getDescriptor(id, 'saveOnBlur');\n    if (typeof saveOnBlurFieldOverride !== 'undefined' && !saveOnBlurFieldOverride) {\n      return null;\n    }\n\n    return this.saveField(id, currentValue);\n  }\n\n  @action\n  setFormSaving() {\n    this.formState = FormState.SAVING;\n  }\n\n  /**\n   * This is called when a field does not saveOnBlur and has an individual \"Save\" button\n   */\n  @action\n  handleSaveField(id: string, currentValue: FieldValue) {\n    const savePromise = this.saveField(id, currentValue);\n\n    if (!savePromise) {\n      return null;\n    }\n\n    return savePromise.then(() => {\n      this.setFieldState(id, 'showSave', false);\n    });\n  }\n\n  /**\n   * Cancel \"Save Field\" state and revert form value back to initial value\n   */\n  @action\n  handleCancelSaveField(id: string) {\n    this.setValue(id, this.initialData[id]);\n    this.setFieldState(id, 'showSave', false);\n  }\n\n  @action\n  setFieldState(id: string, key: string, value: FieldValue) {\n    const state = {\n      ...(this.fieldState.get(id) || {}),\n      [key]: value,\n    };\n    this.fieldState.set(id, state);\n  }\n\n  /**\n   * Set \"saving\" state for field\n   */\n  @action\n  setSaving(id: string, value: FieldValue) {\n    // When saving, reset error state\n    this.setError(id, false);\n    this.setFieldState(id, FormState.SAVING, value);\n    this.setFieldState(id, FormState.READY, !value);\n  }\n\n  /**\n   * Set \"error\" state for field\n   */\n  @action\n  setError(id: string, error: boolean | string) {\n    // Note we don't keep error in `this.fieldState` so that we can easily\n    // See if the form is in an \"error\" state with the `isError` getter\n    if (!!error) {\n      this.formState = FormState.ERROR;\n      this.errors.set(id, error);\n    } else {\n      this.formState = FormState.READY;\n      this.errors.delete(id);\n    }\n\n    // Field should no longer to \"saving\", but is not necessarily \"ready\"\n    this.setFieldState(id, FormState.SAVING, false);\n  }\n\n  /**\n   * Returns true if there are no errors\n   */\n  @action\n  validateForm(): boolean {\n    Array.from(this.fieldDescriptor.keys()).forEach(id => !this.validateField(id));\n\n    return !this.isError;\n  }\n\n  @action\n  handleErrorResponse({responseJSON: resp}: {responseJSON?: any} = {}) {\n    if (!resp) {\n      return;\n    }\n\n    // Show resp msg from API endpoint if possible\n    Object.keys(resp).forEach(id => {\n      //non-field errors can be camelcase or snake case\n      const nonFieldErrors = resp.non_field_errors || resp.nonFieldErrors;\n      if (\n        (id === 'non_field_errors' || id === 'nonFieldErrors') &&\n        Array.isArray(nonFieldErrors) &&\n        nonFieldErrors.length\n      ) {\n        addErrorMessage(nonFieldErrors[0], {duration: 10000});\n      } else if (Array.isArray(resp[id]) && resp[id].length) {\n        // Just take first resp for now\n        this.setError(id, resp[id][0]);\n      }\n    });\n  }\n\n  @action\n  submitSuccess(data: object) {\n    // update initial data\n    this.formState = FormState.READY;\n    this.initialData = data;\n  }\n\n  @action\n  submitError(err: {responseJSON?: any}) {\n    this.formState = FormState.ERROR;\n    this.formErrors = this.mapFormErrors(err.responseJSON);\n    this.handleErrorResponse({responseJSON: this.formErrors});\n  }\n\n  mapFormErrors(responseJSON?: any) {\n    return responseJSON;\n  }\n}\n\nexport default FormModel;\n","function _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\n\nmodule.exports = _initializerDefineProperty;","function _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.');\n}\n\nmodule.exports = _initializerWarningHelper;"],"sourceRoot":""}