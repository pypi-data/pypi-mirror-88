# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['orthogram']

package_data = \
{'': ['*']}

install_requires = \
['python-igraph>=0.8.3,<0.9.0',
 'pyyaml>=5.3.1,<6.0.0',
 'shapely>=1.7.1,<2.0.0',
 'svgwrite>=1.4,<2.0']

setup_kwargs = {
    'name': 'orthogram',
    'version': '0.2.2',
    'description': 'Draw diagrams of graphs.',
    'long_description': 'Orthogram\n=========\n\n**WARNING:** *This is work in progress.  There is no guarantee as to\nthe stability and reliability of this program.*\n\nOrthogram is a command line program and Python library that lets you\ndraw diagrams of graphs.  It reads a YAML file and produces a SVG file\nlike this one:\n\n.. image:: examples/powerplant.svg\n   :width: 100%\n\nOrthogram does not aim to be a fully-featured graph layout solution.\nActually, it offers just a single layout: grid.  More than that, you\nhave to arrange the connected objects manually in the grid and they\nstay fixed in place; the program will not attempt to move them around\ntrying to optimize any aspect of the diagram.  Styling is also rather\nbasic at the moment.  It does however try to do a decent job arranging\nthe connections around the objects to produce a tidy, readable\ndrawing.\n\nWhen used as a command line tool, Orthogram reads a *diagram\ndefinition file* and produces a Scalable Vector Graphics file.  The\ndefinition file is written in YAML.\n\nInstallation\n------------\n\nYou must have Python 3.8 or newer installed in your system.  Run the\nfollowing command to install package ``orthogram`` from PyPi:\n\n.. code:: console\n\n   python -m pip install orthogram\n\nNote however that some of Orthogram\'s dependencies rely on C/C++\nlibraries that you may have to install on your system:\n\n=================  ===========\nPython Package     Library\n=================  ===========\n``python-igraph``  igraph\n``pyyaml``         LibYAML\n``shapely``        GEOS\n=================  ===========\n\nCommand line interface\n----------------------\n\nThe ``orthogram`` module is designed to be used from the command line.\nTo generate a drawing of a diagram defined in a `diagram definition\nfile`_ named ``diagram.yaml``, enter the following command:\n\n.. code:: console\n\n   python -m orthogram diagram.yaml\n\nThis will create a ``diagram.svg`` file in the same directory.  If you\nwish to create a file with a different name or in a different\ndirectory, pass the path as a second argument.\n\nThe program creates Scalable Vector Graphics (SVG) files.  Use your\nweb browser to view the drawing.  Use `Inkscape`_ to convert it to PNG\nor other supported formats.\n\n**NOTE:** The character encoding of the definition file must be UTF-8.\n\n.. _Inkscape: https://inkscape.org\n\nHello world\n-----------\n\nStart the text editor of your choice and type in the following lines\nof YAML:\n\n.. code:: yaml\n\n   terminals:\n     a:\n       label: Hello\n     b:\n       label: world\n   rows:\n     - pins: [a]\n     - pins: ["", b]\n   links:\n     - start: a\n       end: b\n\nSave it as ``hello.yaml`` and run:\n\n.. code:: console\n\n   python -m orthogram hello.yaml\n\nThis should create a ``hello.svg`` file in the same directory.\n\nDiagram definition file\n-----------------------\n\nOrthogram uses YAML for its input file format.  Of course, YAML being\na superset of JSON, you can use JSON if you prefer so.  The top-level\nstructure must be a YAML mapping; the following keys are recognized,\neach one containing a different category of definitions:\n\n* ``diagram``\n* ``terminals``\n* ``rows``\n* ``links``\n* ``styles``\n* ``groups``\n\n``diagram``\n~~~~~~~~~~~\n\nThe ``diagram`` section contains the `attributes`_ of the diagram\nitself.  It is entirely optional; you do not need one if you do not\nintend to customize your diagram.  Here is an example of a ``diagram``\nsection:\n\n.. code:: yaml\n\n   diagram:\n     label: This is my diagram!\n     font_weight: bold\n\nThe following diagram attributes are of particular significance:\n\n``collapse_links``\n  If you set this to ``true``, collinear segments of links belonging\n  to the same ``group`` will collapse into a single segment.  This may\n  help reduce the clutter, though it depends on the application.  Try\n  it out and see.\n\n``stretch``\n  By default, the diagram resizes itself to fill the element that\n  contains it.  Set this attribute to ``false`` to make the browser\n  render the diagram in its original dimensions.\n\n``terminals``\n~~~~~~~~~~~~~\n\nThe ``terminals`` section contains mappings between terminal names and\nterminal definitions.  You must have at least a couple of terminals to\nproduce a meaningful diagram.  Here is an example:\n\n.. code:: yaml\n\n   terminals:\n     a:\n       label: A terminal\n     b:\n       label: Another terminal\n       stroke: blue\n\nIf you want a label with more than one line of text, use the newline\ncharacter in the string.  Even better, you can use the YAML literal\nstyle:\n\n.. code:: yaml\n\n   terminals:\n\n     single-line:\n       label: A single line label\n\n     multi-with-newlines:\n       label: Two lines separated by\\na newline character\n\n     multi-with-newlines-again:\n       label: |-\n         You can also use\n         YAML literal style\n\nNote that if the label of a terminal is not defined, the name of the\nterminal is used as a label instead.\n\n``rows``\n~~~~~~~~\n\nThe ``rows`` section of the diagram definition file is used to arrange\nthe terminals in the layout grid.  It is essential; terminals that\nhave not been placed in the grid are not drawn at all.\n\nThe ``rows`` structure is a sequence of row definitions.  Each row\ndefinition contains a sequence of terminal names.  You can use an\nempty string between the terminal names to leave an empty spot in the\nrow.  Here is an example:\n\n.. code:: yaml\n\n   terminals:\n     a:\n     b:\n     c:\n   rows:\n     - pins: [a]\n     - pins: [b, "", c]\n\nNote that the ``pins`` key is necessary.  Row definitions do not have\nany attributes, though this may change in the future.\n\nA terminal can have many pins in multiple rows as long as the area\nthey occupy in the grid is rectangular.  This way you can draw\nterminals that span multiple diagram rows or columns.  The following\nexample contains valid arrangements:\n\n.. code:: yaml\n\n   rows:\n     - pins: [a, b , b , c, c]\n     - pins: [a, "", "", c, c]\n\nHowever, the program will reject the following invalid arrangements:\n\n.. code:: yaml\n\n   # These are wrong!  Terminal \'a\' has a gap; terminal \'b\' is\n   # L-shaped.\n   rows:\n     - pins: [a , "", a , b, ""]\n     - pins: ["", "", "", b, b ]\n\n``links``\n~~~~~~~~~\n\nThe ``links`` section defines the connections between the terminals.\nIt is a sequence of link definitions. Each link must declare the names\nof the ``start`` and ``end`` terminals, as well as any `attributes`_\nappropriate for links.  Note that the terminals must have at least one\npin placed before making a connection. Here is an example:\n\n.. code:: yaml\n\n   terminals:\n     a: {label: First terminal}\n     b: {label: Second terminal}\n     c: {label: Third terminal}\n   rows:\n     - pins: [a,  b]\n     - pins: ["", c]\n   links:\n     - start: a\n       end: b\n       stroke: blue\n     - start: b\n       end: c\n       stroke: "#FF8844"\n\nNote that the ``start`` and ``end`` values of a link definition can be\n*sequences* of terminal names as well.  This lets you make multiple\nconnections in a single definition, all links sharing the same\nattributes.  For example, the following definition creates six links:\n\n.. code:: yaml\n\n   links:\n     - start: [a, b]\n       end: [c, d, e]\n\nOf particular interest is the ``drawing_priority`` attribute.  Links\nwith a higher priority number are drawn over links with a lower\npriority.  Since the intersection of links cannot typically be avoided\nin complex diagrams, it is advised that you draw intersecting links\nwith a different ``stroke`` color to make obvious that the links are\nnot connected at the intersection points.  The ``drawing_priority``\nlets you draw sets of links as layers on top of each other, giving a\nmore consistent look to your diagram.\n\nAnother way to avoid intersecting links appearing as if the were\nconnected at the intersections is to draw a *buffer* around the links.\nAttributes ``buffer_fill`` and ``buffer_width`` control the appearance\nof the buffer.  By default, the program draws the links without a\nbuffer.\n\nLinks may have an additional ``group`` attribute, which works together\nwith the ``collapse_links`` diagram attribute.  If ``collapse_links``\nis set to true, links of the same group that run along the same axis\ncan be drawn on top of each other, thus reducing the clutter and size\nof the diagram.  The ``group`` value is just a string.  Note that\nsetting this attribute affects the drawing priority of the links.  All\nlinks in the same group must share the same priority, which is the\nhighest priority among all links in the group.\n\n``styles``\n~~~~~~~~~~\n\nYou can add style definitions to the ``styles`` section to create\nnamed styles that can be referred to by the terminals, links and\ngroups.  Each style definition consists of attribute key-value pairs.\nFor example, the following two terminals are drawn in the same color:\n\n.. code:: yaml\n\n   terminals:\n     a:\n       style: reddish\n     b:\n       style: reddish\n   rows:\n     - pins: [a, b]\n   styles:\n     reddish:\n       stroke: "#880000"\n       stroke_width: 3.0\n       fill: "#FFDDDD"\n\nYou add style references to an element using the ``style`` attribute.\nThe value of this attribute can be either a single style name or a\nlist of style names.  When in a list, later styles override the ones\ncoming before them.  Attributes you define in the element itself\noverride the attributes it inherits from the referenced named styles.\n\nThere are two special style names, ``default_terminal`` and\n``default_link``, which you can use to set default values for all the\nterminals and links in the diagram respectively.\n\nStyles themselves *cannot* reference other styles, i.e. the program\nignores the ``style`` attribute in style definitions.\n\n``groups``\n~~~~~~~~~~\n\nThe ``groups`` section may be used to attach attributes to link\ngroups.  Since links in the same group may collapse on one another, it\nis usually desirable for all the links in one group to share the same\nattributes.  In the example that follows, all links are drawn in blue:\n\n.. code:: yaml\n\n   groups:\n     water:\n       stroke: blue\n       stroke_width: 4.0\n   links:\n     - start: a\n       end: b\n       group: water\n     - start: c\n       end: d\n       group: water\n\nA group definition may contain references to named styles.  Note that\ncreating an entry in the ``groups`` section is not necessary for the\ngrouping of the links; a common ``group`` name in each link definition\nis sufficient.\n\nAttributes\n----------\n\nThe following table summarizes the attributes available to the diagram\nand its components.  Where an attribute is applicable, it shows the\ndefault value:\n\n====================  ===============  ============  =======\nAttribute             Diagram          Terminal      Link\n====================  ===============  ============  =======\n``arrow_aspect``                                     1.5\n``arrow_back``                                       False\n``arrow_base``                                       3.0\n``arrow_forward``                                    True\n``buffer_fill``                                      "none"\n``buffer_width``                                     0.0\n``collapse_links``    False\n``column_margin``     24.0\n``drawing_priority``                                 0\n``end_bias``                                         None\n``fill``              "none"           "none"\n``font_family``       None             None          None\n``font_size``         14.0             10.0\n``font_style``        None             None          None\n``font_weight``       None             None          None\n``group``                                            None\n``label_distance``    6.0\n``label_position``    "top"\n``label``             None             None\n``link_distance``     4.0\n``min_height``        300.0            48.0\n``min_width``         300.0            96.0\n``padding``           0.0\n``row_margin``        24.0\n``start_bias``                                       None\n``stretch``           True\n``stroke_dasharray``  None             None          None\n``stroke_width``      0.0              2.0           2.0\n``stroke``            "none"           "black"       "black"\n``text_fill``         "black"          "black"\n``text_line_height``  1.25             1.25\n``text_orientation``                   "horizontal"\n====================  ===============  ============  =======\n\nThe options for the enumerated attributes are:\n\n* ``label_position``:\n\n  * ``bottom``\n  * ``top``\n\n* ``start_bias`` and ``end_bias``:\n\n  * ``horizontal``\n  * ``vertical``\n\n* ``text_orientation``:\n\n  * ``horizontal``\n  * ``vertical``\n\nAPI\n---\n\nUsing the ``Diagram`` class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIf you want to create a diagram using Python, you can start by\ncreating an empty ``Diagram`` object:\n\n.. code:: python\n\n   from orthogram import Diagram, write_svg\n\n   diagram = Diagram(label="A hand-made diagram", text_fill="blue")\n\nYou can pass any diagram `attributes`_ to the constructor as key-value\npairs.\n\nYou can now add terminals to the diagram:\n\n.. code:: python\n\n   diagram.add_terminal("a", label="Hello")\n   diagram.add_terminal("b", label="Beautiful")\n   diagram.add_terminal("c", label="World")\n\nAgain, you can provide `attributes`_ for the terminals as key-value\npairs.\n\nIn order to use the terminals, you must first place pins for them in\nthe grid:\n\n.. code:: python\n\n   diagram.add_row(["a"])\n   diagram.add_row(["b", "", "c"])\n\nThe ``add_row`` method takes a list of terminal names.  Note that you\nmust have added the terminals to the diagram before placing pins for\nthem in the grid.  Use an empty string or None to leave an empty space\nbetween terminals.\n\nAfter placing the terminals, you can connect them via links like this:\n\n.. code:: python\n\n   diagram.add_link("a", "b", stroke="red")\n\nNote that the ``Diagram`` class offers an ``add_links`` method as\nwell, which lets you create links en masse (all having the same\nattributes).\n\nAfter you have finished building your diagram, use the ``write_svg()``\nfunction to write the SVG file:\n\n.. code:: python\n\n   write_svg(diagram, "hello.svg")\n\nUsing the ``Builder`` class\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``Builder`` class lets you create ``Diagram`` objects from Python\ndictionaries like the ones you load from a YAML file.  The ``add()``\nmethod imports a complete diagram definition into the builder:\n\n.. code:: python\n\n   import yaml\n   from orthogram import Builder, write_svg\n\n   builder = Builder()\n   with open("diagram.yaml") as f:\n       data = yaml.safe_load(f)\n       builder.add(data)\n   write_svg(builder.diagram, "diagram.svg")\n\nIf you have to be more specific, ``Builder`` provides the following\nmethods:\n\n=======================  ===================\nDo one                   Do many\n=======================  ===================\n``add_style()``          ``add_styles()``\n``add_group()``          ``add_groups()``\n``add_terminal()``       ``add_terminals()``\n``add_row()``            ``add_rows()``\n``add_link()``           ``add_links()``\n``configure_diagram()``\n=======================  ===================\n\nFor example:\n\n.. code:: python\n\n   terminal_def = {\n       \'label\': "Hello",\n       \'fill\': "yellow",\n       \'stroke\': "none",\n   }\n   builder.add_terminal(\'hello\', terminal_def)\n\nUse the ``help()`` Python function to read the documentation of each\nmethod.  Note that you have to do the imports in a logical order: you\nmust import the styles before using them, place the pins before\nlinking the terminals etc.\n\nThe ``diagram`` property of a ``Builder`` object holds the diagram\nwhich is being built.  If you want to use the ``Diagram`` API on it,\nas described in the previous section, after or while using the\nbuilder, you can certainly do so.\n\nConvenience functions\n~~~~~~~~~~~~~~~~~~~~~\n\nThe ``load_ddf()`` and ``translate()`` functions are provided as\nshortcuts:\n\n.. code:: python\n\n   from orthogram import load_ddf, translate, write_svg\n\n   # You can do this:\n   diagram = load_ddf("diagram.yaml")\n   write_svg(diagram, "diagram.svg")\n\n   # or just this:\n   translate("diagram.yaml", "diagram.svg")\n\nAcknowledgements\n----------------\n\nThis program depends on the following excellent pieces of software:\n\n* `Python`_: The author\'s preferred programming language.  Flexible,\n  convenient and nice to look at.  Has a library for everything.\n\n* `python-igraph`_: Python interface to the powerful `igraph`_\n  library.  Orthogram uses it everywhere in its layout engine.  The\n  performance offered by the C-based implementation is much needed.\n\n* `pyyaml`_: Simple to use, efficient YAML parser.\n\n* `shapely`_: Python interface to the powerful `GEOS`_ geometry\n  library.  A bit overkill for the simple geometry manipulations\n  Orthogram does, but why reinvent the wheel?\n\n* `svgwrite`_: Orthogram uses this library to write the SVG files.\n  Much better than having to use straight XML!\n\nThe following programs improved the development experience of the\nauthor a lot:\n\n* `mypy`_: Python static analyzer.  Makes refactoring so much easier.\n\n* `Poetry`_: Great Python package manager.  Also made publishing to\n  PyPI a breeze.\n\n.. _Python: https://python.org\n.. _python-igraph: https://igraph.org/python/\n.. _igraph: https://igraph.org/\n.. _shapely: https://github.com/Toblerity/Shapely\n.. _GEOS: https://trac.osgeo.org/geos\n.. _svgwrite: https://github.com/mozman/svgwrite\n.. _pyyaml: https://github.com/yaml/pyyaml\n.. _Poetry: https://python-poetry.org/\n.. _mypy: http://mypy-lang.org/\n\nRelease history\n---------------\n\n0.1.0 (2020-12-09)\n~~~~~~~~~~~~~~~~~~\n\n* First release.\n* Important functionality already in place.\n\n0.1.1 (2020-12-10)\n~~~~~~~~~~~~~~~~~~\n\n* API breaking change: renamed ``convert_ddf()`` public function to\n  the arguably more user friendly ``translate()``.\n\n* Added the ``arrow_aspect`` and ``arrow_base`` attributes.\n\n* Fixed bug when ``buffer_width`` is not set.\n\n* Updated the documentation to reflect the changes and correct a few\n  errors; made the stability warning a bit less scary.\n\n* Added the scripts.\n\n0.2.0 (2020-12-14)\n~~~~~~~~~~~~~~~~~~\n\n* Introduced the ability to create shapes spanning multiple rows and\n  columns.\n\n* Major API breaking changes: Replaced ``nodes`` with ``terminals``\n  and ``pins`` in order to facilitate the expansion of connected\n  objects.  Both API and diagram definition files affected.\n\n* Added the ``text_orientation`` attribute.\n\n* Updated the documentation to reflect the changes.  Added the\n  acknowledgments and release history sections.\n\n0.2.1 (2020-12-15)\n~~~~~~~~~~~~~~~~~~\n\n* Enforced the UTF-8 character encoding for the definition file.\n\n0.2.2 (2020-12-16)\n~~~~~~~~~~~~~~~~~~\n\n* Enabled multiple style references in definition files.\n* Made debug switch compatible with Python 3.8.\n',
    'author': 'Georgios Athanasiou',
    'author_email': 'yorgath@gmail.com',
    'maintainer': 'Georgios Athanasiou',
    'maintainer_email': 'yorgath@gmail.com',
    'url': 'https://github.com/yorgath/orthogram',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
