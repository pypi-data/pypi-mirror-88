{"version":3,"sources":["libraries/scroller.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","define","browser","layoutManager","dom","focusManager","ResizeObserver","disableOneEvent","event","preventDefault","stopPropagation","this","removeEventListener","type","within","number","min","max","dragMouseEvents","dragTouchEvents","wheelEvent","document","implementation","hasFeature","interactiveElements","abs","Math","sqrt","pow","round","scrollerFactory","frame","options","o","Object","assign","slidee","horizontal","mouseWheel","scrollBy","dragSource","mouseDragging","touchDragging","dragThreshold","intervactive","speed","isSmoothScrollSupported","documentElement","style","allowNativeScroll","enableNativeScroll","firefox","tv","allowNativeSmoothScroll","requireAnimation","animate","supportsCssAnimation","web0s","self","slideeElement","sibling","n","elem","matched","nextSibling","nodeType","push","firstChild","_pos","start","center","end","cur","dest","transform","scrollSource","dragSourceElement","dragging","released","scrolling","last","delta","resetTime","initialized","nativeScrollElement","lastAnimate","requiresReflow","frameSize","slideeSize","ensureSizeInfo","offsetWidth","offsetHeight","scrollWidth","load","isInit","pos","slideTo","setStyleProperty","name","value","resetTransition","edge","transition","getBoundingClientRect","top","left","dragInitSlidee","isTouch","init","isInteractive","element","indexOf","tagName","parentNode","target","which","source","touch","pointer","touches","initX","pageX","initY","pageY","initPos","Date","time","path","locked","pathToLock","forEach","eventName","addEventListener","dragHandler","passive","pathX","pathY","dragEnd","undefined","setTimeout","scrollHandler","normalizeWheelDelta","curDelta","deltaX","deltaY","deltaMode","slideBy","scrollLeft","scrollTop","reload","getScrollEventName","getScrollSlider","getScrollFrame","newPos","immediate","fullItemPos","now","getTime","autoImmediate","skipSlideToWhenVisible","isVisible","renderAnimateWithTransform","fromPosition","toPosition","immediateSpeed","dispatchScrollEventIfNeeded","dispatchScrollEvent","dispatchEvent","CustomEvent","bubbles","cancelable","from","nativeScrollTo","container","scroll","behavior","scrollTo","getPos","item","slideeOffset","itemOffset","offset","right","bottom","size","width","height","centerOffset","currentStart","currentEnd","console","debug","getCenterPosition","destroy","frameResizeObserver","disconnect","resetScroll","onFrameClick","capture","contentRect","onResize","entries","entry","newRect","e","focusableParent","activeElement","focus","getScrollPosition","getScrollSize","scrollHeight","overflow","classList","add","desktop","hideScrollbar","forceHideScrollbars","initFrameResizeObserver","observe","to","location","String","toString","call","match","toLowerCase","itemPos","toStart","toEnd","toCenter","create","instance","Promise","resolve"],"mappings":"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","file":"scroller.js","sourcesContent":["define(['browser', 'layoutManager', 'dom', 'focusManager', 'ResizeObserver', 'scrollStyles'], function (browser, layoutManager, dom, focusManager, ResizeObserver) {\n    'use strict';\n\n    /**\n* Return type of the value.\n*\n* @param  {Mixed} value\n*\n* @return {String}\n*/\n    function type(value) {\n        if (value == null) {\n            return String(value);\n        }\n\n        if (typeof value === 'object' || typeof value === 'function') {\n            return Object.prototype.toString.call(value).match(/\\s([a-z]+)/i)[1].toLowerCase() || 'object';\n        }\n\n        return typeof value;\n    }\n\n    /**\n\t * Disables an event it was triggered on and unbinds itself.\n\t *\n\t * @param  {Event} event\n\t *\n\t * @return {Void}\n\t */\n    function disableOneEvent(event) {\n        /*jshint validthis:true */\n        event.preventDefault();\n        event.stopPropagation();\n        this.removeEventListener(event.type, disableOneEvent);\n    }\n\n    /**\n\t * Make sure that number is within the limits.\n\t *\n\t * @param {Number} number\n\t * @param {Number} min\n\t * @param {Number} max\n\t *\n\t * @return {Number}\n\t */\n    function within(number, min, max) {\n        return number < min ? min : number > max ? max : number;\n    }\n\n    // Other global values\n    var dragMouseEvents = ['mousemove', 'mouseup'];\n    var dragTouchEvents = ['touchmove', 'touchend'];\n    var wheelEvent = (document.implementation.hasFeature('Event.wheel', '3.0') ? 'wheel' : 'mousewheel');\n    var interactiveElements = ['INPUT', 'SELECT', 'TEXTAREA'];\n    var tmpArray = [];\n    var time;\n\n    // Math shorthands\n    var abs = Math.abs;\n    var sqrt = Math.sqrt;\n    var pow = Math.pow;\n    var round = Math.round;\n    var max = Math.max;\n    var min = Math.min;\n\n    var scrollerFactory = function (frame, options) {\n\n        // Extend options\n        var o = Object.assign({}, {\n            slidee: null, // Selector, DOM element, or jQuery object with DOM element representing SLIDEE.\n            horizontal: false, // Switch to horizontal mode.\n\n            // Scrolling\n            mouseWheel: true,\n            scrollBy: 0, // Pixels or items to move per one mouse scroll. 0 to disable scrolling\n\n            // Dragging\n            dragSource: null, // Selector or DOM element for catching dragging events. Default is FRAME.\n            mouseDragging: 1, // Enable navigation by dragging the SLIDEE with mouse cursor.\n            touchDragging: 1, // Enable navigation by dragging the SLIDEE with touch events.\n            dragThreshold: 3, // Distance in pixels before Sly recognizes dragging.\n            intervactive: null, // Selector for special interactive elements.\n\n            // Mixed options\n            speed: 0 // Animations speed in milliseconds. 0 to disable animations.\n\n        }, options);\n\n        var isSmoothScrollSupported = 'scrollBehavior' in document.documentElement.style;\n\n        // native scroll is a must with touch input\n        // also use native scroll when scrolling vertically in desktop mode - excluding horizontal because the mouse wheel support is choppy at the moment\n        // in cases with firefox, if the smooth scroll api is supported then use that because their implementation is very good\n        if (options.allowNativeScroll === false) {\n            options.enableNativeScroll = false;\n        } else if (isSmoothScrollSupported && ((browser.firefox && !layoutManager.tv) || options.allowNativeSmoothScroll)) {\n            // native smooth scroll\n            options.enableNativeScroll = true;\n        } else if (options.requireAnimation && (browser.animate || browser.supportsCssAnimation())) {\n\n            // transform is the only way to guarantee animation\n            options.enableNativeScroll = false;\n        } else if (!layoutManager.tv || !browser.animate) {\n\n            options.enableNativeScroll = true;\n        }\n\n        // Need this for the magic wheel. With the animated scroll the magic wheel will run off of the screen\n        if (browser.web0s) {\n            options.enableNativeScroll = true;\n        }\n\n        // Private variables\n        var self = this;\n        self.options = o;\n\n        // Frame\n        var slideeElement = o.slidee ? o.slidee : sibling(frame.firstChild)[0];\n        self._pos = {\n            start: 0,\n            center: 0,\n            end: 0,\n            cur: 0,\n            dest: 0\n        };\n\n        var transform = !options.enableNativeScroll;\n\n        // Miscellaneous\n        var scrollSource = frame;\n        var dragSourceElement = o.dragSource ? o.dragSource : frame;\n        var dragging = {\n            released: 1\n        };\n        var scrolling = {\n            last: 0,\n            delta: 0,\n            resetTime: 200\n        };\n\n        // Expose properties\n        self.initialized = 0;\n        self.slidee = slideeElement;\n        self.options = o;\n        self.dragging = dragging;\n\n        var nativeScrollElement = frame;\n\n        function sibling(n, elem) {\n            var matched = [];\n\n            for (; n; n = n.nextSibling) {\n                if (n.nodeType === 1 && n !== elem) {\n                    matched.push(n);\n                }\n            }\n            return matched;\n        }\n\n        var requiresReflow = true;\n\n        var frameSize = 0;\n        var slideeSize = 0;\n        function ensureSizeInfo() {\n\n            if (requiresReflow) {\n\n                requiresReflow = false;\n\n                // Reset global variables\n                frameSize = o.horizontal ? (frame).offsetWidth : (frame).offsetHeight;\n\n                slideeSize = o.scrollWidth || Math.max(slideeElement[o.horizontal ? 'offsetWidth' : 'offsetHeight'], slideeElement[o.horizontal ? 'scrollWidth' : 'scrollHeight']);\n\n                // Set position limits & relativess\n                self._pos.end = max(slideeSize - frameSize, 0);\n            }\n        }\n\n        /**\n\t\t * Loading function.\n\t\t *\n\t\t * Populate arrays, set sizes, bind events, ...\n\t\t *\n\t\t * @param {Boolean} [isInit] Whether load is called from within self.init().\n\t\t * @return {Void}\n\t\t */\n        function load(isInit) {\n\n            requiresReflow = true;\n\n            if (!isInit) {\n\n                ensureSizeInfo();\n\n                // Fix possible overflowing\n                var pos = self._pos;\n                self.slideTo(within(pos.dest, pos.start, pos.end));\n            }\n        }\n\n        function initFrameResizeObserver() {\n\n            var observerOptions = {};\n\n            self.frameResizeObserver = new ResizeObserver(onResize, observerOptions);\n\n            self.frameResizeObserver.observe(frame);\n        }\n\n        self.reload = function () {\n            load();\n        };\n\n        self.getScrollEventName = function () {\n            return transform ? 'scrollanimate' : 'scroll';\n        };\n\n        self.getScrollSlider = function () {\n            return slideeElement;\n        };\n\n        self.getScrollFrame = function () {\n            return frame;\n        };\n\n        function nativeScrollTo(container, pos, immediate) {\n\n            if (container.scroll) {\n                if (o.horizontal) {\n\n                    container.scroll({\n                        left: pos,\n                        behavior: immediate ? 'instant' : 'smooth'\n                    });\n                } else {\n\n                    container.scroll({\n                        top: pos,\n                        behavior: immediate ? 'instant' : 'smooth'\n                    });\n                }\n            } else if (!immediate && container.scrollTo) {\n                if (o.horizontal) {\n                    container.scrollTo(Math.round(pos), 0);\n                } else {\n                    container.scrollTo(0, Math.round(pos));\n                }\n            } else {\n                if (o.horizontal) {\n                    container.scrollLeft = Math.round(pos);\n                } else {\n                    container.scrollTop = Math.round(pos);\n                }\n            }\n        }\n\n        var lastAnimate;\n\n        /**\n          * Animate to a position.\n          *\n          * @param {Int}  newPos    New position.\n          * @param {Bool} immediate Reposition immediately without an animation.\n          *\n          * @return {Void}\n          */\n        self.slideTo = function (newPos, immediate, fullItemPos) {\n\n            ensureSizeInfo();\n            var pos = self._pos;\n\n            newPos = within(newPos, pos.start, pos.end);\n\n            if (!transform) {\n\n                nativeScrollTo(nativeScrollElement, newPos, immediate);\n                return;\n            }\n\n            // Update the animation object\n            var from = pos.cur;\n            immediate = immediate || dragging.init || !o.speed;\n\n            var now = new Date().getTime();\n\n            if (o.autoImmediate) {\n                if (!immediate && (now - (lastAnimate || 0)) <= 50) {\n                    immediate = true;\n                }\n            }\n\n            if (!immediate && o.skipSlideToWhenVisible && fullItemPos && fullItemPos.isVisible) {\n\n                return;\n            }\n\n            // Start animation rendering\n            // NOTE the dependency was modified here to fix a scrollbutton issue\n            pos.dest = newPos;\n            renderAnimateWithTransform(from, newPos, immediate);\n            lastAnimate = now;\n        };\n\n        function setStyleProperty(elem, name, value, speed, resetTransition) {\n\n            var style = elem.style;\n\n            if (resetTransition || browser.edge) {\n                style.transition = 'none';\n                void elem.offsetWidth;\n            }\n\n            style.transition = 'transform ' + speed + 'ms ease-out';\n            style[name] = value;\n        }\n\n        function dispatchScrollEventIfNeeded() {\n            if (o.dispatchScrollEvent) {\n                frame.dispatchEvent(new CustomEvent(self.getScrollEventName(), {\n                    bubbles: true,\n                    cancelable: false\n                }));\n            }\n        }\n\n        function renderAnimateWithTransform(fromPosition, toPosition, immediate) {\n\n            var speed = o.speed;\n\n            if (immediate) {\n                speed = o.immediateSpeed || 50;\n            }\n\n            if (o.horizontal) {\n                setStyleProperty(slideeElement, 'transform', 'translateX(' + (-round(toPosition)) + 'px)', speed);\n            } else {\n                setStyleProperty(slideeElement, 'transform', 'translateY(' + (-round(toPosition)) + 'px)', speed);\n            }\n            self._pos.cur = toPosition;\n\n            dispatchScrollEventIfNeeded();\n        }\n\n        function getBoundingClientRect(elem) {\n\n            // Support: BlackBerry 5, iOS 3 (original iPhone)\n            // If we don't have gBCR, just use 0,0 rather than error\n            if (elem.getBoundingClientRect) {\n                return elem.getBoundingClientRect();\n            } else {\n                return { top: 0, left: 0 };\n            }\n        }\n\n        /**\n         * Returns the position object.\n         *\n         * @param {Mixed} item\n         *\n         * @return {Object}\n         */\n        self.getPos = function (item) {\n\n            var scrollElement = transform ? slideeElement : nativeScrollElement;\n            var slideeOffset = getBoundingClientRect(scrollElement);\n            var itemOffset = getBoundingClientRect(item);\n\n            var slideeStartPos = o.horizontal ? slideeOffset.left : slideeOffset.top;\n            var slideeEndPos = o.horizontal ? slideeOffset.right : slideeOffset.bottom;\n\n            var offset = o.horizontal ? itemOffset.left - slideeOffset.left : itemOffset.top - slideeOffset.top;\n\n            var size = o.horizontal ? itemOffset.width : itemOffset.height;\n            if (!size && size !== 0) {\n                size = item[o.horizontal ? 'offsetWidth' : 'offsetHeight'];\n            }\n\n            var centerOffset = o.centerOffset || 0;\n\n            if (!transform) {\n                centerOffset = 0;\n                if (o.horizontal) {\n                    offset += nativeScrollElement.scrollLeft;\n                } else {\n                    offset += nativeScrollElement.scrollTop;\n                }\n            }\n\n            ensureSizeInfo();\n\n            var currentStart = self._pos.cur;\n            var currentEnd = currentStart + frameSize;\n\n            console.debug('offset:' + offset + ' currentStart:' + currentStart + ' currentEnd:' + currentEnd);\n            var isVisible = offset >= currentStart && (offset + size) <= currentEnd;\n\n            return {\n                start: offset,\n                center: offset + centerOffset - (frameSize / 2) + (size / 2),\n                end: offset - frameSize + size,\n                size: size,\n                isVisible: isVisible\n            };\n        };\n\n        self.getCenterPosition = function (item) {\n\n            ensureSizeInfo();\n\n            var pos = self.getPos(item);\n            return within(pos.center, pos.start, pos.end);\n        };\n\n        function dragInitSlidee(event) {\n            var isTouch = event.type === 'touchstart';\n\n            // Ignore when already in progress, or interactive element in non-touch navivagion\n            if (dragging.init || !isTouch && isInteractive(event.target)) {\n                return;\n            }\n\n            // SLIDEE dragging conditions\n            if (!(isTouch ? o.touchDragging : o.mouseDragging && event.which < 2)) {\n                return;\n            }\n\n            if (!isTouch) {\n                // prevents native image dragging in Firefox\n                event.preventDefault();\n            }\n\n            // Reset dragging object\n            dragging.released = 0;\n\n            // Properties used in dragHandler\n            dragging.init = 0;\n            dragging.source = event.target;\n            dragging.touch = isTouch;\n            var pointer = isTouch ? event.touches[0] : event;\n            dragging.initX = pointer.pageX;\n            dragging.initY = pointer.pageY;\n            dragging.initPos = self._pos.cur;\n            dragging.start = +new Date();\n            dragging.time = 0;\n            dragging.path = 0;\n            dragging.delta = 0;\n            dragging.locked = 0;\n            dragging.pathToLock = isTouch ? 30 : 10;\n\n            // Bind dragging events\n            if (transform) {\n\n                if (isTouch) {\n                    dragTouchEvents.forEach(function (eventName) {\n                        dom.addEventListener(document, eventName, dragHandler, {\n                            passive: true\n                        });\n                    });\n                } else {\n                    dragMouseEvents.forEach(function (eventName) {\n                        dom.addEventListener(document, eventName, dragHandler, {\n                            passive: true\n                        });\n                    });\n                }\n            }\n        }\n\n        /**\n\t\t * Handler for dragging scrollbar handle or SLIDEE.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n        function dragHandler(event) {\n            dragging.released = event.type === 'mouseup' || event.type === 'touchend';\n            var pointer = dragging.touch ? event[dragging.released ? 'changedTouches' : 'touches'][0] : event;\n            dragging.pathX = pointer.pageX - dragging.initX;\n            dragging.pathY = pointer.pageY - dragging.initY;\n            dragging.path = sqrt(pow(dragging.pathX, 2) + pow(dragging.pathY, 2));\n            dragging.delta = o.horizontal ? dragging.pathX : dragging.pathY;\n\n            if (!dragging.released && dragging.path < 1) {\n                return;\n            }\n\n            // We haven't decided whether this is a drag or not...\n            if (!dragging.init) {\n                // If the drag path was very short, maybe it's not a drag?\n                if (dragging.path < o.dragThreshold) {\n                    // If the pointer was released, the path will not become longer and it's\n                    // definitely not a drag. If not released yet, decide on next iteration\n                    return dragging.released ? dragEnd() : undefined;\n                } else {\n                    // If dragging path is sufficiently long we can confidently start a drag\n                    // if drag is in different direction than scroll, ignore it\n                    if (o.horizontal ? abs(dragging.pathX) > abs(dragging.pathY) : abs(dragging.pathX) < abs(dragging.pathY)) {\n                        dragging.init = 1;\n                    } else {\n                        return dragEnd();\n                    }\n                }\n            }\n\n            //event.preventDefault();\n\n            // Disable click on a source element, as it is unwelcome when dragging\n            if (!dragging.locked && dragging.path > dragging.pathToLock) {\n                dragging.locked = 1;\n                dragging.source.addEventListener('click', disableOneEvent);\n            }\n\n            // Cancel dragging on release\n            if (dragging.released) {\n                dragEnd();\n            }\n\n            self.slideTo(round(dragging.initPos - dragging.delta));\n        }\n\n        /**\n\t\t * Stops dragging and cleans up after it.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n        function dragEnd() {\n            dragging.released = true;\n\n            dragTouchEvents.forEach(function (eventName) {\n                dom.removeEventListener(document, eventName, dragHandler, {\n                    passive: true\n                });\n            });\n\n            dragMouseEvents.forEach(function (eventName) {\n                dom.removeEventListener(document, eventName, dragHandler, {\n                    passive: true\n                });\n            });\n\n            // Make sure that disableOneEvent is not active in next tick.\n            setTimeout(function () {\n                dragging.source.removeEventListener('click', disableOneEvent);\n            });\n\n            dragging.init = 0;\n        }\n\n        /**\n\t\t * Check whether element is interactive.\n\t\t *\n\t\t * @return {Boolean}\n\t\t */\n        function isInteractive(element) {\n\n            while (element) {\n\n                if (interactiveElements.indexOf(element.tagName) !== -1) {\n                    return true;\n                }\n\n                element = element.parentNode;\n            }\n            return false;\n        }\n\n        /**\n\t\t * Mouse wheel delta normalization.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Int}\n\t\t */\n        function normalizeWheelDelta(event) {\n            // JELLYFIN MOD: Only use deltaX for horizontal scroll and remove IE8 support\n            scrolling.curDelta = o.horizontal ? event.deltaX : event.deltaY;\n            // END JELLYFIN MOD\n\n            if (transform) {\n                scrolling.curDelta /= event.deltaMode === 1 ? 3 : 100;\n            }\n            return scrolling.curDelta;\n        }\n\n        /**\n\t\t * Mouse scrolling handler.\n\t\t *\n\t\t * @param  {Event} event\n\t\t *\n\t\t * @return {Void}\n\t\t */\n        function scrollHandler(event) {\n\n            ensureSizeInfo();\n            var pos = self._pos;\n            // Ignore if there is no scrolling to be done\n            if (!o.scrollBy || pos.start === pos.end) {\n                return;\n            }\n            var delta = normalizeWheelDelta(event);\n\n            if (transform) {\n                // Trap scrolling only when necessary and/or requested\n                if (delta > 0 && pos.dest < pos.end || delta < 0 && pos.dest > pos.start) {\n                    //stopDefault(event, 1);\n                }\n\n                self.slideBy(o.scrollBy * delta);\n            } else {\n\n                if (isSmoothScrollSupported) {\n                    delta *= 12;\n                }\n\n                if (o.horizontal) {\n                    nativeScrollElement.scrollLeft += delta;\n                } else {\n                    nativeScrollElement.scrollTop += delta;\n                }\n            }\n        }\n\n        /**\n\t\t * Destroys instance and everything it created.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n        self.destroy = function () {\n\n            if (self.frameResizeObserver) {\n                self.frameResizeObserver.disconnect();\n                self.frameResizeObserver = null;\n            }\n\n            // Reset native FRAME element scroll\n            dom.removeEventListener(frame, 'scroll', resetScroll, {\n                passive: true\n            });\n\n            dom.removeEventListener(scrollSource, wheelEvent, scrollHandler, {\n                passive: true\n            });\n\n            dom.removeEventListener(dragSourceElement, 'touchstart', dragInitSlidee, {\n                passive: true\n            });\n\n            dom.removeEventListener(frame, 'click', onFrameClick, {\n                passive: true,\n                capture: true\n            });\n\n            dom.removeEventListener(dragSourceElement, 'mousedown', dragInitSlidee, {\n                //passive: true\n            });\n\n            // Reset initialized status and return the instance\n            self.initialized = 0;\n            return self;\n        };\n\n        var contentRect = {};\n\n        function onResize(entries) {\n\n            var entry = entries[0];\n\n            if (entry) {\n\n                var newRect = entry.contentRect;\n\n                // handle element being hidden\n                if (newRect.width === 0 || newRect.height === 0) {\n                    return;\n                }\n\n                if (newRect.width !== contentRect.width || newRect.height !== contentRect.height) {\n\n                    contentRect = newRect;\n\n                    load(false);\n                }\n            }\n        }\n\n        function resetScroll() {\n            if (o.horizontal) {\n                this.scrollLeft = 0;\n            } else {\n                this.scrollTop = 0;\n            }\n        }\n\n        function onFrameClick(e) {\n            if (e.which === 1) {\n                var focusableParent = focusManager.focusableParent(e.target);\n                if (focusableParent && focusableParent !== document.activeElement) {\n                    focusableParent.focus();\n                }\n            }\n        }\n\n        self.getScrollPosition = function () {\n\n            if (transform) {\n                return self._pos.cur;\n            }\n\n            if (o.horizontal) {\n                return nativeScrollElement.scrollLeft;\n            } else {\n                return nativeScrollElement.scrollTop;\n            }\n        };\n\n        self.getScrollSize = function () {\n\n            if (transform) {\n                return slideeSize;\n            }\n\n            if (o.horizontal) {\n                return nativeScrollElement.scrollWidth;\n            } else {\n                return nativeScrollElement.scrollHeight;\n            }\n        };\n\n        /**\n\t\t * Initialize.\n\t\t *\n\t\t * @return {Object}\n\t\t */\n        self.init = function () {\n            if (self.initialized) {\n                return;\n            }\n\n            if (!transform) {\n                if (o.horizontal) {\n                    if (layoutManager.desktop && !o.hideScrollbar) {\n                        nativeScrollElement.classList.add('scrollX');\n                    } else {\n                        nativeScrollElement.classList.add('scrollX');\n                        nativeScrollElement.classList.add('hiddenScrollX');\n\n                        if (layoutManager.tv && o.allowNativeSmoothScroll !== false) {\n                            nativeScrollElement.classList.add('smoothScrollX');\n                        }\n                    }\n\n                    if (o.forceHideScrollbars) {\n                        nativeScrollElement.classList.add('hiddenScrollX-forced');\n                    }\n                } else {\n                    if (layoutManager.desktop && !o.hideScrollbar) {\n                        nativeScrollElement.classList.add('scrollY');\n                    } else {\n                        nativeScrollElement.classList.add('scrollY');\n                        nativeScrollElement.classList.add('hiddenScrollY');\n\n                        if (layoutManager.tv && o.allowNativeSmoothScroll !== false) {\n                            nativeScrollElement.classList.add('smoothScrollY');\n                        }\n                    }\n\n                    if (o.forceHideScrollbars) {\n                        nativeScrollElement.classList.add('hiddenScrollY-forced');\n                    }\n                }\n            } else {\n                frame.style.overflow = 'hidden';\n                slideeElement.style['will-change'] = 'transform';\n                slideeElement.style.transition = 'transform ' + o.speed + 'ms ease-out';\n\n                if (o.horizontal) {\n                    slideeElement.classList.add('animatedScrollX');\n                } else {\n                    slideeElement.classList.add('animatedScrollY');\n                }\n            }\n\n            if (transform || layoutManager.tv) {\n                // This can prevent others from being able to listen to mouse events\n                dom.addEventListener(dragSourceElement, 'mousedown', dragInitSlidee, {\n                    //passive: true\n                });\n            }\n\n            initFrameResizeObserver();\n\n            if (transform) {\n\n                dom.addEventListener(dragSourceElement, 'touchstart', dragInitSlidee, {\n                    passive: true\n                });\n\n                if (!o.horizontal) {\n                    dom.addEventListener(frame, 'scroll', resetScroll, {\n                        passive: true\n                    });\n                }\n\n                if (o.mouseWheel) {\n                    // Scrolling navigation\n                    dom.addEventListener(scrollSource, wheelEvent, scrollHandler, {\n                        passive: true\n                    });\n                }\n\n            } else if (o.horizontal) {\n\n                // Don't bind to mouse events with vertical scroll since the mouse wheel can handle this natively\n\n                if (o.mouseWheel) {\n                    // Scrolling navigation\n                    dom.addEventListener(scrollSource, wheelEvent, scrollHandler, {\n                        passive: true\n                    });\n                }\n            }\n\n            dom.addEventListener(frame, 'click', onFrameClick, {\n                passive: true,\n                capture: true\n            });\n\n            // Mark instance as initialized\n            self.initialized = 1;\n\n            // Load\n            load(true);\n\n            // Return instance\n            return self;\n        };\n    };\n\n    /**\n     * Slide SLIDEE by amount of pixels.\n     *\n     * @param {Int}  delta     Pixels/Items. Positive means forward, negative means backward.\n     * @param {Bool} immediate Reposition immediately without an animation.\n     *\n     * @return {Void}\n     */\n    scrollerFactory.prototype.slideBy = function (delta, immediate) {\n        if (!delta) {\n            return;\n        }\n        this.slideTo(this._pos.dest + delta, immediate);\n    };\n\n    /**\n     * Core method for handling `toLocation` methods.\n     *\n     * @param  {String} location\n     * @param  {Mixed}  item\n     * @param  {Bool}   immediate\n     *\n     * @return {Void}\n     */\n    scrollerFactory.prototype.to = function (location, item, immediate) {\n        // Optional arguments logic\n        if (type(item) === 'boolean') {\n            immediate = item;\n            item = undefined;\n        }\n\n        if (item === undefined) {\n            this.slideTo(this._pos[location], immediate);\n        } else {\n\n            //if (!transform) {\n\n            //    item.scrollIntoView();\n            //    return;\n            //}\n\n            var itemPos = this.getPos(item);\n\n            if (itemPos) {\n                this.slideTo(itemPos[location], immediate, itemPos);\n            }\n        }\n    };\n\n    /**\n     * Animate element or the whole SLIDEE to the start of the frame.\n     *\n     * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n     * @param {Bool}  immediate Reposition immediately without an animation.\n     *\n     * @return {Void}\n     */\n    scrollerFactory.prototype.toStart = function (item, immediate) {\n        this.to('start', item, immediate);\n    };\n\n    /**\n     * Animate element or the whole SLIDEE to the end of the frame.\n     *\n     * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n     * @param {Bool}  immediate Reposition immediately without an animation.\n     *\n     * @return {Void}\n     */\n    scrollerFactory.prototype.toEnd = function (item, immediate) {\n        this.to('end', item, immediate);\n    };\n\n    /**\n     * Animate element or the whole SLIDEE to the center of the frame.\n     *\n     * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n     * @param {Bool}  immediate Reposition immediately without an animation.\n     *\n     * @return {Void}\n     */\n    scrollerFactory.prototype.toCenter = function (item, immediate) {\n        this.to('center', item, immediate);\n    };\n\n    scrollerFactory.create = function (frame, options) {\n        var instance = new scrollerFactory(frame, options);\n        return Promise.resolve(instance);\n    };\n\n    return scrollerFactory;\n});\n"]}