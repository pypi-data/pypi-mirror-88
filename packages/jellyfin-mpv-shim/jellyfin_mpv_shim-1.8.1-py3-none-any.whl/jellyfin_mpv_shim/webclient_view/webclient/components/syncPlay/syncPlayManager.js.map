{"version":3,"sources":["components/syncPlay/syncPlayManager.js"],"names":["define","_exports","_events","_connectionManager","_playbackManager","_timeSyncManager","_toast","_globalize","_interopRequireDefault","obj","__esModule","default","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","waitForEventOnce","emitter","eventType","timeout","_arguments","arguments","Promise","resolve","reject","rejectTimeout","setTimeout","events","on","callback","off","clearTimeout","getActivePlayerId","info","playbackManager","getPlayerInfo","id","value","_default","SyncPlayManager","_this","this","_classCallCheck","instance","Constructor","TypeError","playbackRateSupported","syncEnabled","playbackDiffMillis","syncMethod","syncAttempts","lastSyncTime","Date","syncWatcherTimeout","lastPlaybackWaiting","minBufferingThresholdMillis","currentPlayer","localPlayerPlaybackRate","syncPlayEnabledAt","syncPlayReady","lastCommand","queuedCommand","scheduledCommand","syncTimeout","timeOffsetWithServer","roundTripDuration","notifySyncPlayReady","player","state","onPlaybackStart","stopInfo","onPlaybackStop","onPlayerChange","bindToPlayer","getCurrentPlayer","event","syncPlaybackTime","timeSyncManager","error","timeOffset","ping","console","debug","trigger","apiClient","connectionManager","currentApiClient","signalError","text","globalize","translate","sendSyncPlayPing","Ping","_createClass","protoProps","staticProps","prototype","isSyncPlayEnabled","disableSyncPlay","onPlayerUnpause","onPlayerPause","onTimeUpdate","e","onPlaying","onWaiting","isBuffering","releaseCurrentPlayer","self","_onPlayerUnpause","_onPlayerPause","_onTimeUpdate","_onPlaying","_onWaiting","supports","getPlaybackRate","setPlaybackRate","processGroupUpdate","cmd","Type","prepareSession","GroupId","Data","enableSyncPlay","processCommand","When","EmittedAt","EmitttedAt","PositionTicks","Command","log","schedulePlay","schedulePause","scheduleSeek","groupId","sessionData","_this2","serverId","serverInfo","Id","play","ids","ItemIds","startPositionTicks","StartPositionTicks","mediaSourceId","MediaSourceId","audioStreamIndex","AudioStreamIndex","subtitleStreamIndex","SubtitleStreamIndex","startIndex","StartIndex","then","playingItemId","playState","getPlayerState","NowPlayingItem","success","localPause","warning","joinSyncPlayGroup","PlayingItemId","catch","enabledAt","_this3","showMessage","undefined","injectPlaybackManager","forceUpdate","restorePlaybackManager","playAtTime","positionTicks","_this4","clearScheduledCommand","currentTime","playAtTimeLocal","serverDateToLocal","playTimeout","localSeek","localUnpause","SyncMethodThreshold","serverPositionTicks","pauseAtTime","_this5","pauseAtTimeLocal","pauseTimeout","seekAtTime","clearSyncIcon","syncPlayEnabled","_localUnpause","unpause","_localPause","pause","_localSeek","seek","playRequest","pauseRequest","seekRequest","requestSyncPlayStart","requestSyncPlayPause","requestSyncPlaySeek","_this6","currentPositionTicks","diffMillis","absDiffMillis","Math","abs","speed","showSyncIcon","getStats","TimeOffset","PlaybackDiff","SyncMethod"],"mappings":"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","file":"syncPlayManager.js","sourcesContent":["/**\n * Module that manages the SyncPlay feature.\n * @module components/syncPlay/syncPlayManager\n */\n\nimport events from 'events';\nimport connectionManager from 'connectionManager';\nimport playbackManager from 'playbackManager';\nimport timeSyncManager from 'timeSyncManager';\nimport toast from 'toast';\nimport globalize from 'globalize';\n\n/**\n * Waits for an event to be triggered on an object. An optional timeout can specified after which the promise is rejected.\n * @param {Object} emitter Object on which to listen for events.\n * @param {string} eventType Event name to listen for.\n * @param {number} timeout Time in milliseconds before rejecting promise if event does not trigger.\n * @returns {Promise} A promise that resolves when the event is triggered.\n */\nfunction waitForEventOnce(emitter, eventType, timeout) {\n    return new Promise((resolve, reject) => {\n        let rejectTimeout;\n        if (timeout) {\n            rejectTimeout = setTimeout(() => {\n                reject('Timed out.');\n            }, timeout);\n        }\n        const callback = () => {\n            events.off(emitter, eventType, callback);\n            if (rejectTimeout) {\n                clearTimeout(rejectTimeout);\n            }\n            resolve(arguments);\n        };\n        events.on(emitter, eventType, callback);\n    });\n}\n\n/**\n * Gets active player id.\n * @returns {string} The player's id.\n */\nfunction getActivePlayerId() {\n    var info = playbackManager.getPlayerInfo();\n    return info ? info.id : null;\n}\n\n/**\n * Playback synchronization\n */\nconst MaxAcceptedDelaySpeedToSync = 50; // milliseconds, delay after which SpeedToSync is enabled\nconst MaxAcceptedDelaySkipToSync = 300; // milliseconds, delay after which SkipToSync is enabled\nconst SyncMethodThreshold = 2000; // milliseconds, switches between SpeedToSync or SkipToSync\nconst SpeedToSyncTime = 1000; // milliseconds, duration in which the playback is sped up\nconst MaxAttemptsSpeedToSync = 3; // attempts before disabling SpeedToSync\nconst MaxAttemptsSync = 5; // attempts before disabling syncing at all\n\n/**\n * Other constants\n */\nconst WaitForEventDefaultTimeout = 30000; // milliseconds\nconst WaitForPlayerEventTimeout = 500; // milliseconds\n\n/**\n * Class that manages the SyncPlay feature.\n */\nclass SyncPlayManager {\n    constructor() {\n        this.playbackRateSupported = false;\n        this.syncEnabled = false;\n        this.playbackDiffMillis = 0; // used for stats\n        this.syncMethod = 'None'; // used for stats\n        this.syncAttempts = 0;\n        this.lastSyncTime = new Date();\n        this.syncWatcherTimeout = null; // interval that watches playback time and syncs it\n\n        this.lastPlaybackWaiting = null; // used to determine if player's buffering\n        this.minBufferingThresholdMillis = 1000;\n\n        this.currentPlayer = null;\n        this.localPlayerPlaybackRate = 1.0; // used to restore user PlaybackRate\n\n        this.syncPlayEnabledAt = null; // Server time of when SyncPlay has been enabled\n        this.syncPlayReady = false; // SyncPlay is ready after first ping to server\n\n        this.lastCommand = null;\n        this.queuedCommand = null;\n\n        this.scheduledCommand = null;\n        this.syncTimeout = null;\n\n        this.timeOffsetWithServer = 0; // server time minus local time\n        this.roundTripDuration = 0;\n        this.notifySyncPlayReady = false;\n\n        events.on(playbackManager, 'playbackstart', (player, state) => {\n            this.onPlaybackStart(player, state);\n        });\n\n        events.on(playbackManager, 'playbackstop', (stopInfo) => {\n            this.onPlaybackStop(stopInfo);\n        });\n\n        events.on(playbackManager, 'playerchange', () => {\n            this.onPlayerChange();\n        });\n\n        this.bindToPlayer(playbackManager.getCurrentPlayer());\n\n        events.on(this, 'timeupdate', (event) => {\n            this.syncPlaybackTime();\n        });\n\n        events.on(timeSyncManager, 'update', (event, error, timeOffset, ping) => {\n            if (error) {\n                console.debug('SyncPlay, time update issue', error);\n                return;\n            }\n\n            this.timeOffsetWithServer = timeOffset;\n            this.roundTripDuration = ping * 2;\n\n            if (this.notifySyncPlayReady) {\n                this.syncPlayReady = true;\n                events.trigger(this, 'ready');\n                this.notifySyncPlayReady = false;\n            }\n\n            // Report ping\n            if (this.syncEnabled) {\n                const apiClient = connectionManager.currentApiClient();\n                const sessionId = getActivePlayerId();\n\n                if (!sessionId) {\n                    this.signalError();\n                    toast({\n                        text: globalize.translate('MessageSyncPlayErrorMissingSession')\n                    });\n                    return;\n                }\n\n                apiClient.sendSyncPlayPing({\n                    Ping: ping\n                });\n            }\n        });\n    }\n\n    /**\n     * Called when playback starts.\n     */\n    onPlaybackStart (player, state) {\n        events.trigger(this, 'playbackstart', [player, state]);\n    }\n\n    /**\n     * Called when playback stops.\n     */\n    onPlaybackStop (stopInfo) {\n        events.trigger(this, 'playbackstop', [stopInfo]);\n        if (this.isSyncPlayEnabled()) {\n            this.disableSyncPlay(false);\n        }\n    }\n\n    /**\n     * Called when the player changes.\n     */\n    onPlayerChange () {\n        this.bindToPlayer(playbackManager.getCurrentPlayer());\n        events.trigger(this, 'playerchange', [this.currentPlayer]);\n    }\n\n    /**\n     * Called when playback unpauses.\n     */\n    onPlayerUnpause () {\n        events.trigger(this, 'unpause', [this.currentPlayer]);\n    }\n\n    /**\n     * Called when playback pauses.\n     */\n    onPlayerPause() {\n        events.trigger(this, 'pause', [this.currentPlayer]);\n    }\n\n    /**\n     * Called on playback progress.\n     * @param {Object} e The time update event.\n     */\n    onTimeUpdate (e) {\n        // NOTICE: this event is unreliable, at least in Safari\n        // which just stops firing the event after a while.\n        events.trigger(this, 'timeupdate', [e]);\n    }\n\n    /**\n     * Called when playback is resumed.\n     */\n    onPlaying () {\n        // TODO: implement group wait\n        this.lastPlaybackWaiting = null;\n        events.trigger(this, 'playing');\n    }\n\n    /**\n     * Called when playback is buffering.\n     */\n    onWaiting () {\n        // TODO: implement group wait\n        if (!this.lastPlaybackWaiting) {\n            this.lastPlaybackWaiting = new Date();\n        }\n\n        events.trigger(this, 'waiting');\n    }\n\n    /**\n     * Gets playback buffering status.\n     * @returns {boolean} _true_ if player is buffering, _false_ otherwise.\n     */\n    isBuffering () {\n        if (this.lastPlaybackWaiting === null) return false;\n        return (new Date() - this.lastPlaybackWaiting) > this.minBufferingThresholdMillis;\n    }\n\n    /**\n     * Binds to the player's events.\n     * @param {Object} player The player.\n     */\n    bindToPlayer (player) {\n        if (player !== this.currentPlayer) {\n            this.releaseCurrentPlayer();\n            this.currentPlayer = player;\n            if (!player) return;\n        }\n\n        // FIXME: the following are needed because the 'events' module\n        // is changing the scope when executing the callbacks.\n        // For instance, calling 'onPlayerUnpause' from the wrong scope breaks things because 'this'\n        // points to 'player' (the event emitter) instead of pointing to the SyncPlayManager singleton.\n        const self = this;\n        this._onPlayerUnpause = () => {\n            self.onPlayerUnpause();\n        };\n\n        this._onPlayerPause = () => {\n            self.onPlayerPause();\n        };\n\n        this._onTimeUpdate = (e) => {\n            self.onTimeUpdate(e);\n        };\n\n        this._onPlaying = () => {\n            self.onPlaying();\n        };\n\n        this._onWaiting = () => {\n            self.onWaiting();\n        };\n\n        events.on(player, 'unpause', this._onPlayerUnpause);\n        events.on(player, 'pause', this._onPlayerPause);\n        events.on(player, 'timeupdate', this._onTimeUpdate);\n        events.on(player, 'playing', this._onPlaying);\n        events.on(player, 'waiting', this._onWaiting);\n\n        // Save player current PlaybackRate value\n        if (player.supports && player.supports('PlaybackRate')) {\n            this.localPlayerPlaybackRate = player.getPlaybackRate();\n        }\n    }\n\n    /**\n     * Removes the bindings to the current player's events.\n     */\n    releaseCurrentPlayer () {\n        var player = this.currentPlayer;\n        if (player) {\n            events.off(player, 'unpause', this._onPlayerUnpause);\n            events.off(player, 'pause', this._onPlayerPause);\n            events.off(player, 'timeupdate', this._onTimeUpdate);\n            events.off(player, 'playing', this._onPlaying);\n            events.off(player, 'waiting', this._onWaiting);\n            // Restore player original PlaybackRate value\n            if (this.playbackRateSupported) {\n                player.setPlaybackRate(this.localPlayerPlaybackRate);\n                this.localPlayerPlaybackRate = 1.0;\n            }\n\n            this.currentPlayer = null;\n            this.playbackRateSupported = false;\n        }\n    }\n\n    /**\n     * Handles a group update from the server.\n     * @param {Object} cmd The group update.\n     * @param {Object} apiClient The ApiClient.\n     */\n    processGroupUpdate (cmd, apiClient) {\n        switch (cmd.Type) {\n            case 'PrepareSession':\n                this.prepareSession(apiClient, cmd.GroupId, cmd.Data);\n                break;\n            case 'UserJoined':\n                toast({\n                    text: globalize.translate('MessageSyncPlayUserJoined', cmd.Data)\n                });\n                break;\n            case 'UserLeft':\n                toast({\n                    text: globalize.translate('MessageSyncPlayUserLeft', cmd.Data)\n                });\n                break;\n            case 'GroupJoined':\n                this.enableSyncPlay(apiClient, new Date(cmd.Data), true);\n                break;\n            case 'NotInGroup':\n            case 'GroupLeft':\n                this.disableSyncPlay(true);\n                break;\n            case 'GroupWait':\n                toast({\n                    text: globalize.translate('MessageSyncPlayGroupWait', cmd.Data)\n                });\n                break;\n            case 'GroupDoesNotExist':\n                toast({\n                    text: globalize.translate('MessageSyncPlayGroupDoesNotExist')\n                });\n                break;\n            case 'CreateGroupDenied':\n                toast({\n                    text: globalize.translate('MessageSyncPlayCreateGroupDenied')\n                });\n                break;\n            case 'JoinGroupDenied':\n                toast({\n                    text: globalize.translate('MessageSyncPlayJoinGroupDenied')\n                });\n                break;\n            case 'LibraryAccessDenied':\n                toast({\n                    text: globalize.translate('MessageSyncPlayLibraryAccessDenied')\n                });\n                break;\n            default:\n                console.error('processSyncPlayGroupUpdate: command is not recognised: ' + cmd.Type);\n                break;\n        }\n    }\n\n    /**\n     * Handles a playback command from the server.\n     * @param {Object} cmd The playback command.\n     * @param {Object} apiClient The ApiClient.\n     */\n    processCommand (cmd, apiClient) {\n        if (cmd === null) return;\n\n        if (!this.isSyncPlayEnabled()) {\n            console.debug('SyncPlay processCommand: SyncPlay not enabled, ignoring command', cmd);\n            return;\n        }\n\n        if (!this.syncPlayReady) {\n            console.debug('SyncPlay processCommand: SyncPlay not ready, queued command', cmd);\n            this.queuedCommand = cmd;\n            return;\n        }\n\n        cmd.When = new Date(cmd.When);\n        cmd.EmittedAt = new Date(cmd.EmitttedAt);\n\n        if (cmd.EmitttedAt < this.syncPlayEnabledAt) {\n            console.debug('SyncPlay processCommand: ignoring old command', cmd);\n            return;\n        }\n\n        // Check if new command differs from last one\n        if (this.lastCommand &&\n            this.lastCommand.When === cmd.When &&\n            this.lastCommand.PositionTicks === cmd.PositionTicks &&\n            this.Command === cmd.Command\n        ) {\n            console.debug('SyncPlay processCommand: ignoring duplicate command', cmd);\n            return;\n        }\n\n        this.lastCommand = cmd;\n        console.log('SyncPlay will', cmd.Command, 'at', cmd.When, 'PositionTicks', cmd.PositionTicks);\n\n        switch (cmd.Command) {\n            case 'Play':\n                this.schedulePlay(cmd.When, cmd.PositionTicks);\n                break;\n            case 'Pause':\n                this.schedulePause(cmd.When, cmd.PositionTicks);\n                break;\n            case 'Seek':\n                this.scheduleSeek(cmd.When, cmd.PositionTicks);\n                break;\n            default:\n                console.error('processCommand: command is not recognised: ' + cmd.Type);\n                break;\n        }\n    }\n\n    /**\n     * Prepares this client to join a group by loading the required content.\n     * @param {Object} apiClient The ApiClient.\n     * @param {string} groupId The group to join.\n     * @param {Object} sessionData Info about the content to load.\n     */\n    prepareSession (apiClient, groupId, sessionData) {\n        const serverId = apiClient.serverInfo().Id;\n        playbackManager.play({\n            ids: sessionData.ItemIds,\n            startPositionTicks: sessionData.StartPositionTicks,\n            mediaSourceId: sessionData.MediaSourceId,\n            audioStreamIndex: sessionData.AudioStreamIndex,\n            subtitleStreamIndex: sessionData.SubtitleStreamIndex,\n            startIndex: sessionData.StartIndex,\n            serverId: serverId\n        }).then(() => {\n            waitForEventOnce(this, 'playbackstart', WaitForEventDefaultTimeout).then(() => {\n                var sessionId = getActivePlayerId();\n                if (!sessionId) {\n                    console.error('Missing sessionId!');\n                    toast({\n                        text: globalize.translate('MessageSyncPlayErrorMissingSession')\n                    });\n                    return;\n                }\n\n                // Get playing item id\n                let playingItemId;\n                try {\n                    const playState = playbackManager.getPlayerState();\n                    playingItemId = playState.NowPlayingItem.Id;\n                } catch (error) {\n                    playingItemId = '';\n                }\n                // Make sure the server has received the player state\n                waitForEventOnce(playbackManager, 'reportplayback', WaitForEventDefaultTimeout).then((success) => {\n                    this.localPause();\n                    if (!success) {\n                        console.warning('Error reporting playback state to server. Joining group will fail.');\n                    }\n                    apiClient.joinSyncPlayGroup({\n                        GroupId: groupId,\n                        PlayingItemId: playingItemId\n                    });\n                }).catch(() => {\n                    console.error('Timed out while waiting for `reportplayback` event!');\n                    toast({\n                        text: globalize.translate('MessageSyncPlayErrorMedia')\n                    });\n                    return;\n                });\n            }).catch(() => {\n                console.error('Timed out while waiting for `playbackstart` event!');\n                if (!this.isSyncPlayEnabled()) {\n                    toast({\n                        text: globalize.translate('MessageSyncPlayErrorMedia')\n                    });\n                }\n                return;\n            });\n        }).catch((error) => {\n            console.error(error);\n            toast({\n                text: globalize.translate('MessageSyncPlayErrorMedia')\n            });\n        });\n    }\n\n    /**\n     * Enables SyncPlay.\n     * @param {Object} apiClient The ApiClient.\n     * @param {Date} enabledAt When SyncPlay has been enabled. Server side date.\n     * @param {boolean} showMessage Display message.\n     */\n    enableSyncPlay (apiClient, enabledAt, showMessage = false) {\n        this.syncPlayEnabledAt = enabledAt;\n        this.injectPlaybackManager();\n        events.trigger(this, 'enabled', [true]);\n\n        waitForEventOnce(this, 'ready').then(() => {\n            this.processCommand(this.queuedCommand, apiClient);\n            this.queuedCommand = null;\n        });\n\n        this.syncPlayReady = false;\n        this.notifySyncPlayReady = true;\n\n        timeSyncManager.forceUpdate();\n\n        if (showMessage) {\n            toast({\n                text: globalize.translate('MessageSyncPlayEnabled')\n            });\n        }\n    }\n\n    /**\n     * Disables SyncPlay.\n     * @param {boolean} showMessage Display message.\n     */\n    disableSyncPlay (showMessage = false) {\n        this.syncPlayEnabledAt = null;\n        this.syncPlayReady = false;\n        this.lastCommand = null;\n        this.queuedCommand = null;\n        this.syncEnabled = false;\n        events.trigger(this, 'enabled', [false]);\n        this.restorePlaybackManager();\n\n        if (showMessage) {\n            toast({\n                text: globalize.translate('MessageSyncPlayDisabled')\n            });\n        }\n    }\n\n    /**\n     * Gets SyncPlay status.\n     * @returns {boolean} _true_ if user joined a group, _false_ otherwise.\n     */\n    isSyncPlayEnabled () {\n        return this.syncPlayEnabledAt !== null;\n    }\n\n    /**\n     * Schedules a resume playback on the player at the specified clock time.\n     * @param {Date} playAtTime The server's UTC time at which to resume playback.\n     * @param {number} positionTicks The PositionTicks from where to resume.\n     */\n    schedulePlay (playAtTime, positionTicks) {\n        this.clearScheduledCommand();\n        const currentTime = new Date();\n        const playAtTimeLocal = timeSyncManager.serverDateToLocal(playAtTime);\n\n        if (playAtTimeLocal > currentTime) {\n            const playTimeout = playAtTimeLocal - currentTime;\n            this.localSeek(positionTicks);\n\n            this.scheduledCommand = setTimeout(() => {\n                this.localUnpause();\n\n                this.syncTimeout = setTimeout(() => {\n                    this.syncEnabled = true;\n                }, SyncMethodThreshold / 2);\n\n            }, playTimeout);\n\n            console.debug('Scheduled play in', playTimeout / 1000.0, 'seconds.');\n        } else {\n            // Group playback already started\n            const serverPositionTicks = positionTicks + (currentTime - playAtTimeLocal) * 10000;\n            waitForEventOnce(this, 'unpause').then(() => {\n                this.localSeek(serverPositionTicks);\n            });\n            this.localUnpause();\n\n            this.syncTimeout = setTimeout(() => {\n                this.syncEnabled = true;\n            }, SyncMethodThreshold / 2);\n        }\n    }\n\n    /**\n     * Schedules a pause playback on the player at the specified clock time.\n     * @param {Date} pauseAtTime The server's UTC time at which to pause playback.\n     * @param {number} positionTicks The PositionTicks where player will be paused.\n     */\n    schedulePause (pauseAtTime, positionTicks) {\n        this.clearScheduledCommand();\n        const currentTime = new Date();\n        const pauseAtTimeLocal = timeSyncManager.serverDateToLocal(pauseAtTime);\n\n        const callback = () => {\n            waitForEventOnce(this, 'pause', WaitForPlayerEventTimeout).then(() => {\n                this.localSeek(positionTicks);\n            }).catch(() => {\n                // Player was already paused, seeking\n                this.localSeek(positionTicks);\n            });\n            this.localPause();\n        };\n\n        if (pauseAtTimeLocal > currentTime) {\n            const pauseTimeout = pauseAtTimeLocal - currentTime;\n            this.scheduledCommand = setTimeout(callback, pauseTimeout);\n\n            console.debug('Scheduled pause in', pauseTimeout / 1000.0, 'seconds.');\n        } else {\n            callback();\n        }\n    }\n\n    /**\n     * Schedules a seek playback on the player at the specified clock time.\n     * @param {Date} pauseAtTime The server's UTC time at which to seek playback.\n     * @param {number} positionTicks The PositionTicks where player will be seeked.\n     */\n    scheduleSeek (seekAtTime, positionTicks) {\n        this.schedulePause(seekAtTime, positionTicks);\n    }\n\n    /**\n     * Clears the current scheduled command.\n     */\n    clearScheduledCommand () {\n        clearTimeout(this.scheduledCommand);\n        clearTimeout(this.syncTimeout);\n\n        this.syncEnabled = false;\n        if (this.currentPlayer) {\n            this.currentPlayer.setPlaybackRate(1);\n        }\n\n        this.clearSyncIcon();\n    }\n\n    /**\n     * Overrides some PlaybackManager's methods to intercept playback commands.\n     */\n    injectPlaybackManager () {\n        if (!this.isSyncPlayEnabled()) return;\n        if (playbackManager.syncPlayEnabled) return;\n\n        // TODO: make this less hacky\n        playbackManager._localUnpause = playbackManager.unpause;\n        playbackManager._localPause = playbackManager.pause;\n        playbackManager._localSeek = playbackManager.seek;\n\n        playbackManager.unpause = this.playRequest;\n        playbackManager.pause = this.pauseRequest;\n        playbackManager.seek = this.seekRequest;\n        playbackManager.syncPlayEnabled = true;\n    }\n\n    /**\n     * Restores original PlaybackManager's methods.\n     */\n    restorePlaybackManager () {\n        if (this.isSyncPlayEnabled()) return;\n        if (!playbackManager.syncPlayEnabled) return;\n\n        playbackManager.unpause = playbackManager._localUnpause;\n        playbackManager.pause = playbackManager._localPause;\n        playbackManager.seek = playbackManager._localSeek;\n        playbackManager.syncPlayEnabled = false;\n    }\n\n    /**\n     * Overrides PlaybackManager's unpause method.\n     */\n    playRequest (player) {\n        var apiClient = connectionManager.currentApiClient();\n        apiClient.requestSyncPlayStart();\n    }\n\n    /**\n     * Overrides PlaybackManager's pause method.\n     */\n    pauseRequest (player) {\n        var apiClient = connectionManager.currentApiClient();\n        apiClient.requestSyncPlayPause();\n        // Pause locally as well, to give the user some little control\n        playbackManager._localUnpause(player);\n    }\n\n    /**\n     * Overrides PlaybackManager's seek method.\n     */\n    seekRequest (PositionTicks, player) {\n        var apiClient = connectionManager.currentApiClient();\n        apiClient.requestSyncPlaySeek({\n            PositionTicks: PositionTicks\n        });\n    }\n\n    /**\n     * Calls original PlaybackManager's unpause method.\n     */\n    localUnpause(player) {\n        if (playbackManager.syncPlayEnabled) {\n            playbackManager._localUnpause(player);\n        } else {\n            playbackManager.unpause(player);\n        }\n    }\n\n    /**\n     * Calls original PlaybackManager's pause method.\n     */\n    localPause(player) {\n        if (playbackManager.syncPlayEnabled) {\n            playbackManager._localPause(player);\n        } else {\n            playbackManager.pause(player);\n        }\n    }\n\n    /**\n     * Calls original PlaybackManager's seek method.\n     */\n    localSeek(PositionTicks, player) {\n        if (playbackManager.syncPlayEnabled) {\n            playbackManager._localSeek(PositionTicks, player);\n        } else {\n            playbackManager.seek(PositionTicks, player);\n        }\n    }\n\n    /**\n     * Attempts to sync playback time with estimated server time.\n     *\n     * When sync is enabled, the following will be checked:\n     *  - check if local playback time is close enough to the server playback time\n     * If it is not, then a playback time sync will be attempted.\n     * Two methods of syncing are available:\n     * - SpeedToSync: speeds up the media for some time to catch up (default is one second)\n     * - SkipToSync: seeks the media to the estimated correct time\n     * SpeedToSync aims to reduce the delay as much as possible, whereas SkipToSync is less pretentious.\n     */\n    syncPlaybackTime () {\n        // Attempt to sync only when media is playing.\n        if (!this.lastCommand || this.lastCommand.Command !== 'Play' || this.isBuffering()) return;\n\n        const currentTime = new Date();\n\n        // Avoid overloading the browser\n        const elapsed = currentTime - this.lastSyncTime;\n        if (elapsed < SyncMethodThreshold / 2) return;\n        this.lastSyncTime = currentTime;\n\n        const playAtTime = this.lastCommand.When;\n\n        const currentPositionTicks = playbackManager.currentTime();\n        // Estimate PositionTicks on server\n        const serverPositionTicks = this.lastCommand.PositionTicks + ((currentTime - playAtTime) + this.timeOffsetWithServer) * 10000;\n        // Measure delay that needs to be recovered\n        // diff might be caused by the player internally starting the playback\n        const diffMillis = (serverPositionTicks - currentPositionTicks) / 10000.0;\n\n        this.playbackDiffMillis = diffMillis;\n\n        if (this.syncEnabled) {\n            const absDiffMillis = Math.abs(diffMillis);\n            // TODO: SpeedToSync sounds bad on songs\n            // TODO: SpeedToSync is failing on Safari (Mojave); even if playbackRate is supported, some delay seems to exist\n            if (this.playbackRateSupported && absDiffMillis > MaxAcceptedDelaySpeedToSync && absDiffMillis < SyncMethodThreshold) {\n                // Disable SpeedToSync if it keeps failing\n                if (this.syncAttempts > MaxAttemptsSpeedToSync) {\n                    this.playbackRateSupported = false;\n                }\n                // SpeedToSync method\n                const speed = 1 + diffMillis / SpeedToSyncTime;\n\n                this.currentPlayer.setPlaybackRate(speed);\n                this.syncEnabled = false;\n                this.syncAttempts++;\n                this.showSyncIcon('SpeedToSync (x' + speed + ')');\n\n                this.syncTimeout = setTimeout(() => {\n                    this.currentPlayer.setPlaybackRate(1);\n                    this.syncEnabled = true;\n                    this.clearSyncIcon();\n                }, SpeedToSyncTime);\n            } else if (absDiffMillis > MaxAcceptedDelaySkipToSync) {\n                // Disable SkipToSync if it keeps failing\n                if (this.syncAttempts > MaxAttemptsSync) {\n                    this.syncEnabled = false;\n                    this.showSyncIcon('Sync disabled (too many attempts)');\n                }\n                // SkipToSync method\n                this.localSeek(serverPositionTicks);\n                this.syncEnabled = false;\n                this.syncAttempts++;\n                this.showSyncIcon('SkipToSync (' + this.syncAttempts + ')');\n\n                this.syncTimeout = setTimeout(() => {\n                    this.syncEnabled = true;\n                    this.clearSyncIcon();\n                }, SyncMethodThreshold / 2);\n            } else {\n                // Playback is synced\n                if (this.syncAttempts > 0) {\n                    console.debug('Playback has been synced after', this.syncAttempts, 'attempts.');\n                }\n                this.syncAttempts = 0;\n            }\n        }\n    }\n\n    /**\n     * Gets SyncPlay stats.\n     * @returns {Object} The SyncPlay stats.\n     */\n    getStats () {\n        return {\n            TimeOffset: this.timeOffsetWithServer,\n            PlaybackDiff: this.playbackDiffMillis,\n            SyncMethod: this.syncMethod\n        };\n    }\n\n    /**\n     * Emits an event to update the SyncPlay status icon.\n     */\n    showSyncIcon (syncMethod) {\n        this.syncMethod = syncMethod;\n        events.trigger(this, 'syncing', [true, this.syncMethod]);\n    }\n\n    /**\n     * Emits an event to clear the SyncPlay status icon.\n     */\n    clearSyncIcon () {\n        this.syncMethod = 'None';\n        events.trigger(this, 'syncing', [false, this.syncMethod]);\n    }\n\n    /**\n     * Signals an error state, which disables and resets SyncPlay for a new session.\n     */\n    signalError () {\n        this.disableSyncPlay();\n    }\n}\n\n/** SyncPlayManager singleton. */\nexport default new SyncPlayManager();\n"]}