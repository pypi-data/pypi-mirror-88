{"version":3,"sources":["components/htmlMediaHelper.js"],"names":["define","appSettings","browser","events","canPlayNativeHls","media","document","createElement","canPlayType","replace","recoverDecodingErrorDate","recoverSwapAudioCodecDate","handleHlsJsMediaError","instance","reject","hlsPlayer","_hlsPlayer","now","Date","window","performance","console","debug","recoverMediaError","swapAudioCodec","error","onErrorInternal","type","destroyCustomTrack","_mediaElement","trigger","isValidDuration","duration","isNaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","setCurrentTimeIfNeeded","element","seconds","Math","abs","currentTime","onSuccessfulPlay","elem","onErrorFn","addEventListener","playWithPromise","promise","play","then","catch","e","errorName","name","toLowerCase","Promise","resolve","err","destroyCastPlayer","player","_castPlayer","unload","destroyHlsPlayer","destroy","destroyFlvPlayer","_flvPlayer","detachMediaElement","getSavedVolume","get","saveVolume","value","set","enableHlsJsPlayer","runTimeTicks","mediaType","MediaSource","iOS","tizen","web0s","android","edge","enableHlsShakaPlayer","item","mediaSource","isTypeSupported","RunTimeTicks","seekOnPlaybackStart","ticks","onMediaReady","currentSrc","onMediaChange","concat","map","removeEventListener","applySrc","src","options","Windows","IsLocal","Storage","StorageFile","getFileFromPathAsync","url","file","playlist","Media","Playback","MediaPlaybackList","source1","Core","createFromStorageFile","startTime","playerStartPositionTicks","items","append","MediaPlaybackItem","URL","createObjectURL","oneTimeOnly","bindEventsToHlsPlayer","hls","on","Hls","Events","MANIFEST_PARSED","ERROR","event","data","details","fatal","ErrorTypes","NETWORK_ERROR","response","code","startLoad","MEDIA_ERROR","currentReject","onEndedInternal","innerHTML","removeAttribute","destroyShakaPlayer","_shakaPlayer","stopInfo","_currentSrc","_currentTime","_currentPlayOptions","getCrossOriginValue","IsRemote","getBufferedRanges","offset","ranges","seekable","buffered","currentPlayOptions","transcodingOffsetTicks","i","length","start","end","push"],"mappings":"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","file":"htmlMediaHelper.js","sourcesContent":["define(['appSettings', 'browser', 'events'], function (appSettings, browser, events) {\n    'use strict';\n\n    function getSavedVolume() {\n        return appSettings.get('volume') || 1;\n    }\n\n    function saveVolume(value) {\n        if (value) {\n            appSettings.set('volume', value);\n        }\n    }\n\n    function getCrossOriginValue(mediaSource) {\n        if (mediaSource.IsRemote) {\n            return null;\n        }\n\n        return 'anonymous';\n    }\n\n    function canPlayNativeHls() {\n        var media = document.createElement('video');\n\n        if (media.canPlayType('application/x-mpegURL').replace(/no/, '') ||\n            media.canPlayType('application/vnd.apple.mpegURL').replace(/no/, '')) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function enableHlsShakaPlayer(item, mediaSource, mediaType) {\n        /* eslint-disable-next-line compat/compat */\n        if (!!window.MediaSource && !!MediaSource.isTypeSupported) {\n\n            if (canPlayNativeHls()) {\n\n                if (browser.edge && mediaType === 'Video') {\n                    return true;\n                }\n\n                // simple playback should use the native support\n                if (mediaSource.RunTimeTicks) {\n                    //if (!browser.edge) {\n                    //return false;\n                    //}\n                }\n\n                //return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    function enableHlsJsPlayer(runTimeTicks, mediaType) {\n\n        if (window.MediaSource == null) {\n            return false;\n        }\n\n        // hls.js is only in beta. needs more testing.\n        if (browser.iOS) {\n            return false;\n        }\n\n        // The native players on these devices support seeking live streams, no need to use hls.js here\n        if (browser.tizen || browser.web0s) {\n            return false;\n        }\n\n        if (canPlayNativeHls()) {\n\n            // Having trouble with chrome's native support and transcoded music\n            if (browser.android && mediaType === 'Audio') {\n                return true;\n            }\n\n            if (browser.edge && mediaType === 'Video') {\n                //return true;\n            }\n\n            // simple playback should use the native support\n            if (runTimeTicks) {\n                //if (!browser.edge) {\n                return false;\n                //}\n            }\n\n            //return false;\n        }\n\n        return true;\n    }\n\n    var recoverDecodingErrorDate;\n    var recoverSwapAudioCodecDate;\n    function handleHlsJsMediaError(instance, reject) {\n\n        var hlsPlayer = instance._hlsPlayer;\n\n        if (!hlsPlayer) {\n            return;\n        }\n\n        var now = Date.now();\n\n        if (window.performance && window.performance.now) {\n            now = performance.now(); // eslint-disable-line compat/compat\n        }\n\n        if (!recoverDecodingErrorDate || (now - recoverDecodingErrorDate) > 3000) {\n            recoverDecodingErrorDate = now;\n            console.debug('try to recover media Error ...');\n            hlsPlayer.recoverMediaError();\n        } else {\n            if (!recoverSwapAudioCodecDate || (now - recoverSwapAudioCodecDate) > 3000) {\n                recoverSwapAudioCodecDate = now;\n                console.debug('try to swap Audio Codec and recover media Error ...');\n                hlsPlayer.swapAudioCodec();\n                hlsPlayer.recoverMediaError();\n            } else {\n                console.error('cannot recover, last media error recovery failed ...');\n\n                if (reject) {\n                    reject();\n                } else {\n                    onErrorInternal(instance, 'mediadecodeerror');\n                }\n            }\n        }\n    }\n\n    function onErrorInternal(instance, type) {\n\n        // Needed for video\n        if (instance.destroyCustomTrack) {\n            instance.destroyCustomTrack(instance._mediaElement);\n        }\n\n        events.trigger(instance, 'error', [\n            {\n                type: type\n            }\n        ]);\n    }\n\n    function isValidDuration(duration) {\n        if (duration && !isNaN(duration) && duration !== Number.POSITIVE_INFINITY && duration !== Number.NEGATIVE_INFINITY) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function setCurrentTimeIfNeeded(element, seconds) {\n        if (Math.abs(element.currentTime || 0, seconds) <= 1) {\n            element.currentTime = seconds;\n        }\n    }\n\n    function seekOnPlaybackStart(instance, element, ticks, onMediaReady) {\n\n        var seconds = (ticks || 0) / 10000000;\n\n        if (seconds) {\n            var src = (instance.currentSrc() || '').toLowerCase();\n\n            // Appending #t=xxx to the query string doesn't seem to work with HLS\n            // For plain video files, not all browsers support it either\n\n            if (element.duration >= seconds) {\n                // media is ready, seek immediately\n                setCurrentTimeIfNeeded(element, seconds);\n                if (onMediaReady) onMediaReady();\n            } else {\n                // update video player position when media is ready to be sought\n                var events = ['durationchange', 'loadeddata', 'play', 'loadedmetadata'];\n                var onMediaChange = function(e) {\n                    if (element.currentTime === 0 && element.duration >= seconds) {\n                        // seek only when video position is exactly zero,\n                        // as this is true only if video hasn't started yet or\n                        // user rewound to the very beginning\n                        // (but rewinding cannot happen as the first event with media of non-empty duration)\n                        console.debug(`seeking to ${seconds} on ${e.type} event`);\n                        setCurrentTimeIfNeeded(element, seconds);\n                        events.map(function(name) {\n                            element.removeEventListener(name, onMediaChange);\n                        });\n                        if (onMediaReady) onMediaReady();\n                    }\n                };\n                events.map(function (name) {\n                    return element.addEventListener(name, onMediaChange);\n                });\n            }\n        }\n    }\n\n    function applySrc(elem, src, options) {\n\n        if (window.Windows && options.mediaSource && options.mediaSource.IsLocal) {\n\n            return Windows.Storage.StorageFile.getFileFromPathAsync(options.url).then(function (file) {\n\n                var playlist = new Windows.Media.Playback.MediaPlaybackList();\n\n                var source1 = Windows.Media.Core.MediaSource.createFromStorageFile(file);\n                var startTime = (options.playerStartPositionTicks || 0) / 10000;\n                playlist.items.append(new Windows.Media.Playback.MediaPlaybackItem(source1, startTime));\n                elem.src = URL.createObjectURL(playlist, { oneTimeOnly: true });\n                return Promise.resolve();\n            });\n\n        } else {\n\n            elem.src = src;\n        }\n\n        return Promise.resolve();\n    }\n\n    function onSuccessfulPlay(elem, onErrorFn) {\n\n        elem.addEventListener('error', onErrorFn);\n    }\n\n    function playWithPromise(elem, onErrorFn) {\n\n        try {\n            var promise = elem.play();\n            if (promise && promise.then) {\n                // Chrome now returns a promise\n                return promise.catch(function (e) {\n\n                    var errorName = (e.name || '').toLowerCase();\n                    // safari uses aborterror\n                    if (errorName === 'notallowederror' ||\n                        errorName === 'aborterror') {\n                        // swallow this error because the user can still click the play button on the video element\n                        onSuccessfulPlay(elem, onErrorFn);\n                        return Promise.resolve();\n                    }\n                    return Promise.reject();\n                });\n            } else {\n                onSuccessfulPlay(elem, onErrorFn);\n                return Promise.resolve();\n            }\n        } catch (err) {\n            console.error('error calling video.play: ' + err);\n            return Promise.reject();\n        }\n    }\n\n    function destroyCastPlayer(instance) {\n\n        var player = instance._castPlayer;\n        if (player) {\n            try {\n                player.unload();\n            } catch (err) {\n                console.error(err);\n            }\n\n            instance._castPlayer = null;\n        }\n    }\n\n    function destroyShakaPlayer(instance) {\n        var player = instance._shakaPlayer;\n        if (player) {\n            try {\n                player.destroy();\n            } catch (err) {\n                console.error(err);\n            }\n\n            instance._shakaPlayer = null;\n        }\n    }\n\n    function destroyHlsPlayer(instance) {\n        var player = instance._hlsPlayer;\n        if (player) {\n            try {\n                player.destroy();\n            } catch (err) {\n                console.error(err);\n            }\n\n            instance._hlsPlayer = null;\n        }\n    }\n\n    function destroyFlvPlayer(instance) {\n        var player = instance._flvPlayer;\n        if (player) {\n            try {\n                player.unload();\n                player.detachMediaElement();\n                player.destroy();\n            } catch (err) {\n                console.error(err);\n            }\n\n            instance._flvPlayer = null;\n        }\n    }\n\n    function bindEventsToHlsPlayer(instance, hls, elem, onErrorFn, resolve, reject) {\n\n        hls.on(Hls.Events.MANIFEST_PARSED, function () {\n            playWithPromise(elem, onErrorFn).then(resolve, function () {\n\n                if (reject) {\n                    reject();\n                    reject = null;\n                }\n            });\n        });\n\n        hls.on(Hls.Events.ERROR, function (event, data) {\n\n            console.error('HLS Error: Type: ' + data.type + ' Details: ' + (data.details || '') + ' Fatal: ' + (data.fatal || false));\n\n            switch (data.type) {\n                case Hls.ErrorTypes.NETWORK_ERROR:\n                    // try to recover network error\n                    if (data.response && data.response.code && data.response.code >= 400) {\n\n                        console.debug('hls.js response error code: ' + data.response.code);\n\n                        // Trigger failure differently depending on whether this is prior to start of playback, or after\n                        hls.destroy();\n\n                        if (reject) {\n                            reject('servererror');\n                            reject = null;\n                        } else {\n                            onErrorInternal(instance, 'servererror');\n                        }\n\n                        return;\n\n                    }\n\n                    break;\n                default:\n                    break;\n            }\n\n            if (data.fatal) {\n                switch (data.type) {\n                    case Hls.ErrorTypes.NETWORK_ERROR:\n\n                        if (data.response && data.response.code === 0) {\n\n                            // This could be a CORS error related to access control response headers\n\n                            console.debug('hls.js response error code: ' + data.response.code);\n\n                            // Trigger failure differently depending on whether this is prior to start of playback, or after\n                            hls.destroy();\n\n                            if (reject) {\n                                reject('network');\n                                reject = null;\n                            } else {\n                                onErrorInternal(instance, 'network');\n                            }\n                        } else {\n                            console.debug('fatal network error encountered, try to recover');\n                            hls.startLoad();\n                        }\n\n                        break;\n                    case Hls.ErrorTypes.MEDIA_ERROR:\n                        console.debug('fatal media error encountered, try to recover');\n                        var currentReject = reject;\n                        reject = null;\n                        handleHlsJsMediaError(instance, currentReject);\n                        break;\n                    default:\n\n                        console.debug('Cannot recover from hls error - destroy and trigger error');\n                        // cannot recover\n                        // Trigger failure differently depending on whether this is prior to start of playback, or after\n                        hls.destroy();\n\n                        if (reject) {\n                            reject();\n                            reject = null;\n                        } else {\n                            onErrorInternal(instance, 'mediadecodeerror');\n                        }\n                        break;\n                }\n            }\n        });\n    }\n\n    function onEndedInternal(instance, elem, onErrorFn) {\n\n        elem.removeEventListener('error', onErrorFn);\n\n        elem.src = '';\n        elem.innerHTML = '';\n        elem.removeAttribute('src');\n\n        destroyHlsPlayer(instance);\n        destroyFlvPlayer(instance);\n        destroyShakaPlayer(instance);\n        destroyCastPlayer(instance);\n\n        var stopInfo = {\n            src: instance._currentSrc\n        };\n\n        events.trigger(instance, 'stopped', [stopInfo]);\n\n        instance._currentTime = null;\n        instance._currentSrc = null;\n        instance._currentPlayOptions = null;\n    }\n\n    function getBufferedRanges(instance, elem) {\n\n        var ranges = [];\n        var seekable = elem.buffered || [];\n\n        var offset;\n        var currentPlayOptions = instance._currentPlayOptions;\n        if (currentPlayOptions) {\n            offset = currentPlayOptions.transcodingOffsetTicks;\n        }\n\n        offset = offset || 0;\n\n        for (var i = 0, length = seekable.length; i < length; i++) {\n\n            var start = seekable.start(i);\n            var end = seekable.end(i);\n\n            if (!isValidDuration(start)) {\n                start = 0;\n            }\n            if (!isValidDuration(end)) {\n                end = 0;\n                continue;\n            }\n\n            ranges.push({\n                start: (start * 10000000) + offset,\n                end: (end * 10000000) + offset\n            });\n        }\n\n        return ranges;\n    }\n\n    return {\n        getSavedVolume: getSavedVolume,\n        saveVolume: saveVolume,\n        enableHlsJsPlayer: enableHlsJsPlayer,\n        enableHlsShakaPlayer: enableHlsShakaPlayer,\n        handleHlsJsMediaError: handleHlsJsMediaError,\n        isValidDuration: isValidDuration,\n        onErrorInternal: onErrorInternal,\n        seekOnPlaybackStart: seekOnPlaybackStart,\n        applySrc: applySrc,\n        playWithPromise: playWithPromise,\n        destroyHlsPlayer: destroyHlsPlayer,\n        destroyFlvPlayer: destroyFlvPlayer,\n        destroyCastPlayer: destroyCastPlayer,\n        bindEventsToHlsPlayer: bindEventsToHlsPlayer,\n        onEndedInternal: onEndedInternal,\n        getCrossOriginValue: getCrossOriginValue,\n        getBufferedRanges: getBufferedRanges\n    };\n});\n"]}