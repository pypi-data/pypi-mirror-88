{"version":3,"sources":["components/scrollManager.js"],"names":["define","_exports","_dom","_browser","_layoutManager","_interopRequireDefault","obj","__esModule","default","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","value","isEnabled","scrollTo","scrollToElement","supportsSmoothScroll","document","documentElement","style","supportsScrollToOptions","elem","createElement","opts","get","e","console","error","clamp","min","max","scrollTimer","documentScroller","DocumentScroller","_classCallCheck","instance","Constructor","TypeError","this","_createClass","protoProps","staticProps","prototype","getBoundingClientRect","left","top","width","clientWidth","height","clientHeight","window","apply","arguments","pageXOffset","set","val","scroll","pageYOffset","Math","scrollWidth","body","scrollHeight","getScrollableParent","element","vertical","nameScroll","nameClient","nameClass","parent","parentElement","classList","contains","getScrollerData","scroller","data","scrollPos","scrollTop","scrollSize","clientSize","scrollLeft","getScrollerChildPos","elementRect","scrollerRect","calcScroll","scrollerData","elementPos","elementSize","centered","maxScroll","delta","fitRange","begin1","end1","begin2","end2","delta1","delta2","round","scrollToHelper","options","scrollX","undefined","scrollY","builtinScroll","xScroller","yScroller","smooth","scrollBehavior","behavior","resetScrollTimer","cancelAnimationFrame","doScroll","useAnimatedScroll","animateScroll","start","ox","oy","dx","dy","abs","requestAnimationFrame","scrollAnim","currentTimestamp","k","ease","t","layoutManager","tv","xScrollerData","yScrollerData","scrollCenterX","scrollCenterY","offsetParent","isFixed","getComputedStyle","position","xPos","yPos","bottom","minimumScrollY","topMenu","querySelector","dom","addEventListener","setTimeout","useSmoothScroll","browser","tizen","capture","_default"],"mappings":"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","file":"scrollManager.js","sourcesContent":["/* eslint-disable indent */\n\n/**\n * Module for controlling scroll behavior.\n * @module components/scrollManager\n */\n\nimport dom from 'dom';\nimport browser from 'browser';\nimport layoutManager from 'layoutManager';\n\n    /**\n     * Scroll time in ms.\n     */\n    const ScrollTime = 270;\n\n    /**\n     * Epsilon for comparing values.\n     */\n    const Epsilon = 1e-6;\n\n    // FIXME: Need to scroll to top of page to fully show the top menu. This can be solved by some marker of top most elements or their containers\n    /**\n     * Returns minimum vertical scroll.\n     * Scroll less than that value will be zeroed.\n     *\n     * @return {number} Minimum vertical scroll.\n     */\n    function minimumScrollY() {\n        const topMenu = document.querySelector('.headerTop');\n        if (topMenu) {\n            return topMenu.clientHeight;\n        }\n        return 0;\n    }\n\n    const supportsSmoothScroll = 'scrollBehavior' in document.documentElement.style;\n\n    let supportsScrollToOptions = false;\n    try {\n        const elem = document.createElement('div');\n\n        const opts = Object.defineProperty({}, 'behavior', {\n            // eslint-disable-next-line getter-return\n            get: function () {\n                supportsScrollToOptions = true;\n            }\n        });\n\n        elem.scrollTo(opts);\n    } catch (e) {\n        console.error('error checking ScrollToOptions support');\n    }\n\n    /**\n     * Returns value clamped by range [min, max].\n     *\n     * @param {number} value - Clamped value.\n     * @param {number} min - Begining of range.\n     * @param {number} max - Ending of range.\n     * @return {number} Clamped value.\n     */\n    function clamp(value, min, max) {\n        return value <= min ? min : value >= max ? max : value;\n    }\n\n    /**\n     * Returns the required delta to fit range 1 into range 2.\n     * In case of range 1 is bigger than range 2 returns delta to fit most out of range part.\n     *\n     * @param {number} begin1 - Begining of range 1.\n     * @param {number} end1 - Ending of range 1.\n     * @param {number} begin2 - Begining of range 2.\n     * @param {number} end2 - Ending of range 2.\n     * @return {number} Delta: <0 move range1 to the left, >0 - to the right.\n     */\n    function fitRange(begin1, end1, begin2, end2) {\n        const delta1 = begin1 - begin2;\n        const delta2 = end2 - end1;\n        if (delta1 < 0 && delta1 < delta2) {\n            return -delta1;\n        } else if (delta2 < 0) {\n            return delta2;\n        }\n        return 0;\n    }\n\n    /**\n     * Ease value.\n     *\n     * @param {number} t - Value in range [0, 1].\n     * @return {number} Eased value in range [0, 1].\n     */\n    function ease(t) {\n        return t * (2 - t); // easeOutQuad === ease-out\n    }\n\n    /**\n     * @typedef {Object} Rect\n     * @property {number} left - X coordinate of top-left corner.\n     * @property {number} top - Y coordinate of top-left corner.\n     * @property {number} width - Width.\n     * @property {number} height - Height.\n     */\n\n    /**\n     * Document scroll wrapper helps to unify scrolling and fix issues of some browsers.\n     *\n     * webOS 2 Browser: scrolls documentElement (and window), but body has a scroll size\n     *\n     * webOS 3 Browser: scrolls body (and window)\n     *\n     * webOS 4 Native: scrolls body (and window); has a document.scrollingElement\n     *\n     * Tizen 4 Browser/Native: scrolls body (and window); has a document.scrollingElement\n     *\n     * Tizen 5 Browser/Native: scrolls documentElement (and window); has a document.scrollingElement\n     */\n    class DocumentScroller {\n        /**\n         * Horizontal scroll position.\n         * @type {number}\n         */\n        get scrollLeft() {\n            return window.pageXOffset;\n        }\n\n        set scrollLeft(val) {\n            window.scroll(val, window.pageYOffset);\n        }\n\n        /**\n         * Vertical scroll position.\n         * @type {number}\n         */\n        get scrollTop() {\n            return window.pageYOffset;\n        }\n\n        set scrollTop(val) {\n            window.scroll(window.pageXOffset, val);\n        }\n\n        /**\n         * Horizontal scroll size (scroll width).\n         * @type {number}\n         */\n        get scrollWidth() {\n            return Math.max(document.documentElement.scrollWidth, document.body.scrollWidth);\n        }\n\n        /**\n         * Vertical scroll size (scroll height).\n         * @type {number}\n         */\n        get scrollHeight() {\n            return Math.max(document.documentElement.scrollHeight, document.body.scrollHeight);\n        }\n\n        /**\n         * Horizontal client size (client width).\n         * @type {number}\n         */\n        get clientWidth() {\n            return Math.min(document.documentElement.clientWidth, document.body.clientWidth);\n        }\n\n        /**\n         * Vertical client size (client height).\n         * @type {number}\n         */\n        get clientHeight() {\n            return Math.min(document.documentElement.clientHeight, document.body.clientHeight);\n        }\n\n        /**\n         * Returns bounding client rect.\n         * @return {Rect} Bounding client rect.\n         */\n        getBoundingClientRect() {\n            // Make valid viewport coordinates: documentElement.getBoundingClientRect returns rect of entire document relative to viewport\n            return {\n                left: 0,\n                top: 0,\n                width: this.clientWidth,\n                height: this.clientHeight\n            };\n        }\n\n        /**\n         * Scrolls window.\n         * @param {...mixed} args See window.scrollTo.\n         */\n        scrollTo() {\n            window.scrollTo.apply(window, arguments);\n        }\n    }\n\n    /**\n     * Default (document) scroller.\n     */\n    const documentScroller = new DocumentScroller();\n\n    /**\n     * Returns parent element that can be scrolled. If no such, returns document scroller.\n     *\n     * @param {HTMLElement} element - Element for which parent is being searched.\n     * @param {boolean} vertical - Search for vertical scrollable parent.\n     * @param {HTMLElement|DocumentScroller} Parent element that can be scrolled or document scroller.\n     */\n    function getScrollableParent(element, vertical) {\n        if (element) {\n            let nameScroll = 'scrollWidth';\n            let nameClient = 'clientWidth';\n            let nameClass = 'scrollX';\n\n            if (vertical) {\n                nameScroll = 'scrollHeight';\n                nameClient = 'clientHeight';\n                nameClass = 'scrollY';\n            }\n\n            let parent = element.parentElement;\n\n            while (parent) {\n                // Skip 'emby-scroller' because it scrolls by itself\n                if (!parent.classList.contains('emby-scroller') &&\n                    parent[nameScroll] > parent[nameClient] && parent.classList.contains(nameClass)) {\n                    return parent;\n                }\n\n                parent = parent.parentElement;\n            }\n        }\n\n        return documentScroller;\n    }\n\n    /**\n     * @typedef {Object} ScrollerData\n     * @property {number} scrollPos - Current scroll position.\n     * @property {number} scrollSize - Scroll size.\n     * @property {number} clientSize - Client size.\n     */\n\n    /**\n     * Returns scroller data for specified orientation.\n     *\n     * @param {HTMLElement} scroller - Scroller.\n     * @param {boolean} vertical - Vertical scroller data.\n     * @return {ScrollerData} Scroller data.\n     */\n    function getScrollerData(scroller, vertical) {\n        let data = {};\n\n        if (!vertical) {\n            data.scrollPos = scroller.scrollLeft;\n            data.scrollSize = scroller.scrollWidth;\n            data.clientSize = scroller.clientWidth;\n        } else {\n            data.scrollPos = scroller.scrollTop;\n            data.scrollSize = scroller.scrollHeight;\n            data.clientSize = scroller.clientHeight;\n        }\n\n        return data;\n    }\n\n    /**\n     * Returns position of child of scroller for specified orientation.\n     *\n     * @param {HTMLElement} scroller - Scroller.\n     * @param {HTMLElement} element - Child of scroller.\n     * @param {boolean} vertical - Vertical scroll.\n     * @return {number} Child position.\n     */\n    function getScrollerChildPos(scroller, element, vertical) {\n        const elementRect = element.getBoundingClientRect();\n        const scrollerRect = scroller.getBoundingClientRect();\n\n        if (!vertical) {\n            return scroller.scrollLeft + elementRect.left - scrollerRect.left;\n        } else {\n            return scroller.scrollTop + elementRect.top - scrollerRect.top;\n        }\n    }\n\n    /**\n     * Returns scroll position for element.\n     *\n     * @param {ScrollerData} scrollerData - Scroller data.\n     * @param {number} elementPos - Child element position.\n     * @param {number} elementSize - Child element size.\n     * @param {boolean} centered - Scroll to center.\n     * @return {number} Scroll position.\n     */\n    function calcScroll(scrollerData, elementPos, elementSize, centered) {\n        const maxScroll = scrollerData.scrollSize - scrollerData.clientSize;\n\n        let scroll;\n\n        if (centered) {\n            scroll = elementPos + (elementSize - scrollerData.clientSize) / 2;\n        } else {\n            const delta = fitRange(elementPos, elementPos + elementSize - 1, scrollerData.scrollPos, scrollerData.scrollPos + scrollerData.clientSize - 1);\n            scroll = scrollerData.scrollPos - delta;\n        }\n\n        return clamp(Math.round(scroll), 0, maxScroll);\n    }\n\n    /**\n     * Calls scrollTo function in proper way.\n     *\n     * @param {HTMLElement} scroller - Scroller.\n     * @param {ScrollToOptions} options - Scroll options.\n     */\n    function scrollToHelper(scroller, options) {\n        if ('scrollTo' in scroller) {\n            if (!supportsScrollToOptions) {\n                const scrollX = (options.left !== undefined ? options.left : scroller.scrollLeft);\n                const scrollY = (options.top !== undefined ? options.top : scroller.scrollTop);\n                scroller.scrollTo(scrollX, scrollY);\n            } else {\n                scroller.scrollTo(options);\n            }\n        } else if ('scrollLeft' in scroller) {\n            if (options.left !== undefined) {\n                scroller.scrollLeft = options.left;\n            }\n            if (options.top !== undefined) {\n                scroller.scrollTop = options.top;\n            }\n        }\n    }\n\n    /**\n     * Performs built-in scroll.\n     *\n     * @param {HTMLElement} xScroller - Horizontal scroller.\n     * @param {number} scrollX - Horizontal coordinate.\n     * @param {HTMLElement} yScroller - Vertical scroller.\n     * @param {number} scrollY - Vertical coordinate.\n     * @param {boolean} smooth - Smooth scrolling.\n     */\n    function builtinScroll(xScroller, scrollX, yScroller, scrollY, smooth) {\n        const scrollBehavior = smooth ? 'smooth' : 'instant';\n\n        if (xScroller !== yScroller) {\n            scrollToHelper(xScroller, {left: scrollX, behavior: scrollBehavior});\n            scrollToHelper(yScroller, {top: scrollY, behavior: scrollBehavior});\n        } else {\n            scrollToHelper(xScroller, {left: scrollX, top: scrollY, behavior: scrollBehavior});\n        }\n    }\n\n    /**\n     * Requested frame for animated scroll.\n     */\n    let scrollTimer;\n\n    /**\n     * Resets scroll timer to stop scrolling.\n     */\n    function resetScrollTimer() {\n        cancelAnimationFrame(scrollTimer);\n        scrollTimer = undefined;\n    }\n\n    /**\n     * Performs animated scroll.\n     *\n     * @param {HTMLElement} xScroller - Horizontal scroller.\n     * @param {number} scrollX - Horizontal coordinate.\n     * @param {HTMLElement} yScroller - Vertical scroller.\n     * @param {number} scrollY - Vertical coordinate.\n     */\n    function animateScroll(xScroller, scrollX, yScroller, scrollY) {\n\n        const ox = xScroller.scrollLeft;\n        const oy = yScroller.scrollTop;\n        const dx = scrollX - ox;\n        const dy = scrollY - oy;\n\n        if (Math.abs(dx) < Epsilon && Math.abs(dy) < Epsilon) {\n            return;\n        }\n\n        let start;\n\n        function scrollAnim(currentTimestamp) {\n\n            start = start || currentTimestamp;\n\n            let k = Math.min(1, (currentTimestamp - start) / ScrollTime);\n\n            if (k === 1) {\n                resetScrollTimer();\n                builtinScroll(xScroller, scrollX, yScroller, scrollY, false);\n                return;\n            }\n\n            k = ease(k);\n\n            const x = ox + dx * k;\n            const y = oy + dy * k;\n\n            builtinScroll(xScroller, x, yScroller, y, false);\n\n            scrollTimer = requestAnimationFrame(scrollAnim);\n        }\n\n        scrollTimer = requestAnimationFrame(scrollAnim);\n    }\n\n    /**\n     * Performs scroll.\n     *\n     * @param {HTMLElement} xScroller - Horizontal scroller.\n     * @param {number} scrollX - Horizontal coordinate.\n     * @param {HTMLElement} yScroller - Vertical scroller.\n     * @param {number} scrollY - Vertical coordinate.\n     * @param {boolean} smooth - Smooth scrolling.\n     */\n    function doScroll(xScroller, scrollX, yScroller, scrollY, smooth) {\n\n        resetScrollTimer();\n\n        if (smooth && useAnimatedScroll()) {\n            animateScroll(xScroller, scrollX, yScroller, scrollY);\n        } else {\n            builtinScroll(xScroller, scrollX, yScroller, scrollY, smooth);\n        }\n    }\n\n    /**\n     * Returns true if smooth scroll must be used.\n     */\n    function useSmoothScroll() {\n\n        if (browser.tizen) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns true if animated implementation of smooth scroll must be used.\n     */\n    function useAnimatedScroll() {\n        // Add block to force using (or not) of animated implementation\n\n        return !supportsSmoothScroll;\n    }\n\n    /**\n     * Returns true if scroll manager is enabled.\n     */\n    export function isEnabled() {\n        return layoutManager.tv;\n    }\n\n    /**\n     * Scrolls the document to a given position.\n     *\n     * @param {number} scrollX - Horizontal coordinate.\n     * @param {number} scrollY - Vertical coordinate.\n     * @param {boolean} [smooth=false] - Smooth scrolling.\n     */\n    export function scrollTo(scrollX, scrollY, smooth) {\n\n        smooth = !!smooth;\n\n        // Scroller is document itself by default\n        const scroller = getScrollableParent(null, false);\n\n        const xScrollerData = getScrollerData(scroller, false);\n        const yScrollerData = getScrollerData(scroller, true);\n\n        scrollX = clamp(Math.round(scrollX), 0, xScrollerData.scrollSize - xScrollerData.clientSize);\n        scrollY = clamp(Math.round(scrollY), 0, yScrollerData.scrollSize - yScrollerData.clientSize);\n\n        doScroll(scroller, scrollX, scroller, scrollY, smooth);\n    }\n\n    /**\n     * Scrolls the document to a given element.\n     *\n     * @param {HTMLElement} element - Target element of scroll task.\n     * @param {boolean} [smooth=false] - Smooth scrolling.\n     */\n    export function scrollToElement(element, smooth) {\n\n        smooth = !!smooth;\n\n        let scrollCenterX = true;\n        let scrollCenterY = true;\n\n        const offsetParent = element.offsetParent;\n\n        // In Firefox offsetParent.offsetParent is BODY\n        const isFixed = offsetParent && (!offsetParent.offsetParent || window.getComputedStyle(offsetParent).position === 'fixed');\n\n        // Scroll fixed elements to nearest edge (or do not scroll at all)\n        if (isFixed) {\n            scrollCenterX = scrollCenterY = false;\n        }\n\n        const xScroller = getScrollableParent(element, false);\n        const yScroller = getScrollableParent(element, true);\n\n        const elementRect = element.getBoundingClientRect();\n\n        const xScrollerData = getScrollerData(xScroller, false);\n        const yScrollerData = getScrollerData(yScroller, true);\n\n        const xPos = getScrollerChildPos(xScroller, element, false);\n        const yPos = getScrollerChildPos(yScroller, element, true);\n\n        const scrollX = calcScroll(xScrollerData, xPos, elementRect.width, scrollCenterX);\n        let scrollY = calcScroll(yScrollerData, yPos, elementRect.height, scrollCenterY);\n\n        // HACK: Scroll to top for top menu because it is hidden\n        // FIXME: Need a marker to scroll top/bottom\n        if (isFixed && elementRect.bottom < 0) {\n            scrollY = 0;\n        }\n\n        // HACK: Ensure we are at the top\n        // FIXME: Need a marker to scroll top/bottom\n        if (scrollY < minimumScrollY() && yScroller === documentScroller) {\n            scrollY = 0;\n        }\n\n        doScroll(xScroller, scrollX, yScroller, scrollY, smooth);\n    }\n\n    if (isEnabled()) {\n        dom.addEventListener(window, 'focusin', function(e) {\n            setTimeout(function() {\n                scrollToElement(e.target, useSmoothScroll());\n            }, 0);\n        }, {capture: true});\n    }\n\n/* eslint-enable indent */\n\nexport default {\n    isEnabled: isEnabled,\n    scrollTo: scrollTo,\n    scrollToElement: scrollToElement\n};\n"]}