{"version":3,"sources":["plugins/chromecastPlayer/chromecastHelpers.js"],"names":["define","events","protocols","linkRegExp","RegExp","protocolRegExp","ensureProtocol","url","match","LinkParser","parse","text","links","exec","console","debug","txt","pos","index","len","length","push","window","cache","clearCache","addToCache","key","value","time","Date","getTime","on","ConnectionManager","getServerAddress","apiClient","serverAddress","isValidIpAddress","address","isLocalIpAddress","toLowerCase","indexOf","Promise","resolve","cachedValue","getCachedValue","obj","getEndpointInfo","then","endpoint","IsInNetwork","getPublicSystemInfo","info","localAddress","LocalAddress"],"mappings":"AAAA,aAAAA,OAAO,CAAC,WAAW,SAAUC,SAYzB,WA2BI,IAAIC,UAAY,qCA4EZC,WAAaC,OAhDb,wnDAgDsC,MAEtCC,eAAiBD,OAAO,IAAMF,UAAW,KAG7C,SAASI,eAAeC,KAIpB,OAHKA,IAAIC,MAAMH,kBACXE,IAAM,UAAYA,KAEfA,IAIX,IAAIE,WAAa,CACbC,MAAO,SAAAA,MAAUC,MAKb,IAJA,IACIH,MADAI,MAAQ,GAILJ,MAAQL,WAAWU,KAAKF,OAAO,CAClCG,QAAQC,MAAMP,OACd,IAAIQ,IAAMR,MAAM,GACZS,IAAMT,MAAMU,MACZC,IAAMH,IAAII,OACVb,IAAMD,eAAeK,MACzBC,MAAMS,KAAK,CAAEJ,IAAOA,IAAKN,KAAQK,IAAKG,IAAOA,IAAKZ,IAAOA,MAG7D,OAAOK,QAKfU,OAAOb,WAAaA,WAxIxB,GA2IA,IAAIc,MAAQ,GAsDZ,SAASC,aACLD,MAAQ,GAGZ,SAASE,WAAWC,IAAKC,OACrBJ,MAAMG,KAAO,CACTC,MAAOA,MACPC,MAAM,IAAIC,MAAOC,WAkBzB,OAHA7B,OAAO8B,GAAGC,kBAAmB,oBAAqBR,YAClDvB,OAAO8B,GAAGC,kBAAmB,qBAAsBR,YAE5C,CACHS,iBAzDJ,SAASA,iBAAiBC,WAEtB,IAAIC,cAAgBD,UAAUC,gBAE9B,GAzBJ,SAASC,iBAAiBC,SAItB,OAAuB,GAFX5B,WAAWC,MAAM2B,SAEhBjB,OAqBTgB,CAAiBD,iBAlBzB,SAASG,iBAAiBD,SAItB,OAAsC,KAFtCA,QAAUA,QAAQE,eAENC,QAAQ,eAGkB,IAAlCH,QAAQG,QAAQ,aAWoBF,CAAiBH,eACrD,OAAOM,QAAQC,QAAQP,eAG3B,IAAIQ,YAkCR,SAASC,eAAelB,KAEpB,IAAImB,IAAMtB,MAAMG,KAEhB,GAAImB,MAAQ,IAAIhB,MAAOC,UAAYe,IAAIjB,KAAQ,KAC3C,OAAOiB,IAAIlB,MAGf,OAAO,KA1CWiB,CAAeT,eACjC,OAAIQ,YACOF,QAAQC,QAAQC,aAGpBT,UAAUY,kBAAkBC,MAAK,SAAUC,UAC9C,OAAIA,SAASC,YACFf,UAAUgB,sBAAsBH,MAAK,SAAUI,MAClD,IAAIC,aAAeD,KAAKE,aAMxB,OALKD,eACDtC,QAAQC,MAAM,+DACdqC,aAAejB,eAEnBV,WAAWU,cAAeiB,cACnBA,iBAGX3B,WAAWU,cAAeA,eACnBA","file":"chromecastHelpers.js","sourcesContent":["define(['events'], function (events) {\n    'use strict';\n\n    // LinkParser\n    //\n    // https://github.com/ravisorg/LinkParser\n    //\n    // Locate and extract almost any URL within a string. Handles protocol-less domains, IPv4 and\n    // IPv6, unrecognised TLDs, and more.\n    //\n    // This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n    // http://creativecommons.org/licenses/by-sa/4.0/\n    (function () {\n\n        // Original URL regex from the Android android.text.util.Linkify function, found here:\n        // http://stackoverflow.com/a/19696443\n        //\n        // However there were problems with it, most probably related to the fact it was\n        // written in 2007, and it's been highly modified.\n        //\n        // 1) I didn't like the fact that it was tied to specific TLDs, since new ones\n        // are being added all the time it wouldn't be reasonable to expect developer to\n        // be continually updating their regular expressions.\n        //\n        // 2) It didn't allow unicode characters in the domains which are now allowed in\n        // many languages, (including some IDN TLDs). Again these are constantly being\n        // added to and it doesn't seem reasonable to hard-code them. Note this ended up\n        // not being possible in standard JS due to the way it handles multibyte strings.\n        // It is possible using XRegExp, however a big performance hit results. Disabled\n        // for now.\n        //\n        // 3) It didn't allow for IPv6 hostnames\n        // IPv6 regex from http://stackoverflow.com/a/17871737\n        //\n        // 4) It was very poorly commented\n        //\n        // 5) It wasn't as smart as it could have been about what should be part of a\n        // URL and what should be part of human language.\n\n        var protocols = '(?:(?:http|https|rtsp|ftp):\\\\/\\\\/)';\n        var credentials = \"(?:(?:[a-z0-9\\\\$\\\\-\\\\_\\\\.\\\\+\\\\!\\\\*\\\\'\\\\(\\\\)\\\\,\\\\;\\\\?\\\\&\\\\=]|(?:\\\\%[a-f0-9]{2})){1,64}\" // username (1-64 normal or url escaped characters)\n            + \"(?:\\\\:(?:[a-z0-9\\\\$\\\\-\\\\_\\\\.\\\\+\\\\!\\\\*\\\\'\\\\(\\\\)\\\\,\\\\;\\\\?\\\\&\\\\=]|(?:\\\\%[a-f0-9]{2})){1,25})?\" // followed by optional password (: + 1-25 normal or url escaped characters)\n            + '\\\\@)';\n\n        // IPv6 Regex http://forums.intermapper.com/viewtopic.php?t=452\n        // by Dartware, LLC is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License\n        // http://intermapper.com/\n        var ipv6 = '('\n            + '(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))'\n            + '|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))'\n            + '|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))'\n            + '|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n            + '|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n            + '|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n            + '|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n            + '|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n            + ')(%.+)?';\n\n        var ipv4 = '(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\\\.'\n            + '(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\\\.'\n            + '(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\\\.'\n            + '(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[0-9])';\n\n        // This would have been a lot cleaner if JS RegExp supported conditionals...\n        var linkRegExpString =\n\n            // begin match for protocol / username / password / host\n            '(?:'\n\n            // ============================\n            // If we have a recognized protocol at the beginning of the URL, we're\n            // more relaxed about what we accept, because we assume the user wants\n            // this to be a URL, and we're not accidentally matching human language\n            + protocols + '?'\n\n            // optional username:password@\n            + credentials + '?'\n\n            // IP address (both v4 and v6)\n            + '(?:'\n\n            // IPv6\n            + ipv6\n\n            // IPv4\n            + '|' + ipv4\n\n            + ')'\n\n            // end match for protocol / username / password / host\n            + ')'\n\n            // optional port number\n            + '(?:\\\\:\\\\d{1,5})?'\n\n            // plus optional path and query params (no unicode allowed here?)\n            + '(?:'\n            + '\\\\/(?:'\n            // some characters we'll accept because it's unlikely human language\n            // would use them after a URL unless they were part of the url\n            + '(?:[a-z0-9\\\\/\\\\@\\\\&\\\\#\\\\~\\\\*\\\\_\\\\-\\\\+])'\n            + '|(?:\\\\%[a-f0-9]{2})'\n            // some characters are much more likely to be used AFTER a url and\n            // were not intended to be included in the url itself. Mostly end\n            // of sentence type things. It's also likely that the URL would\n            // still work if any of these characters were missing from the end\n            // because we parsed it incorrectly. For these characters to be accepted\n            // they must be followed by another character that we're reasonably\n            // sure is part of the url\n            + \"|(?:[\\\\;\\\\?\\\\:\\\\.\\\\!\\\\'\\\\(\\\\)\\\\,\\\\=]+(?=(?:[a-z0-9\\\\/\\\\@\\\\&\\\\#\\\\~\\\\*\\\\_\\\\-\\\\+])|(?:\\\\%[a-f0-9]{2})))\"\n            + ')*'\n            + '|\\\\b|\\$'\n            + ')';\n\n        // regex = XRegExp(regex,'gi');\n        var linkRegExp = RegExp(linkRegExpString, 'gi');\n\n        var protocolRegExp = RegExp('^' + protocols, 'i');\n\n        // if url doesn't begin with a known protocol, add http by default\n        function ensureProtocol(url) {\n            if (!url.match(protocolRegExp)) {\n                url = 'http://' + url;\n            }\n            return url;\n        }\n\n        // look for links in the text\n        var LinkParser = {\n            parse: function (text) {\n                var links = [];\n                var match;\n\n                // eslint-disable-next-line no-cond-assign\n                while (match = linkRegExp.exec(text)) {\n                    console.debug(match);\n                    var txt = match[0];\n                    var pos = match.index;\n                    var len = txt.length;\n                    var url = ensureProtocol(text);\n                    links.push({ 'pos': pos, 'text': txt, 'len': len, 'url': url });\n                }\n\n                return links;\n            }\n\n        };\n\n        window.LinkParser = LinkParser;\n    })();\n\n    var cache = {};\n\n    function isValidIpAddress(address) {\n\n        var links = LinkParser.parse(address);\n\n        return links.length == 1;\n    }\n\n    function isLocalIpAddress(address) {\n\n        address = address.toLowerCase();\n\n        if (address.indexOf('127.0.0.1') !== -1) {\n            return true;\n        }\n        if (address.indexOf('localhost') !== -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function getServerAddress(apiClient) {\n\n        var serverAddress = apiClient.serverAddress();\n\n        if (isValidIpAddress(serverAddress) && !isLocalIpAddress(serverAddress)) {\n            return Promise.resolve(serverAddress);\n        }\n\n        var cachedValue = getCachedValue(serverAddress);\n        if (cachedValue) {\n            return Promise.resolve(cachedValue);\n        }\n\n        return apiClient.getEndpointInfo().then(function (endpoint) {\n            if (endpoint.IsInNetwork) {\n                return apiClient.getPublicSystemInfo().then(function (info) {\n                    var localAddress = info.LocalAddress;\n                    if (!localAddress) {\n                        console.debug('No valid local address returned, defaulting to external one');\n                        localAddress = serverAddress;\n                    }\n                    addToCache(serverAddress, localAddress);\n                    return localAddress;\n                });\n            } else {\n                addToCache(serverAddress, serverAddress);\n                return serverAddress;\n            }\n        });\n    }\n\n    function clearCache() {\n        cache = {};\n    }\n\n    function addToCache(key, value) {\n        cache[key] = {\n            value: value,\n            time: new Date().getTime()\n        };\n    }\n\n    function getCachedValue(key) {\n\n        var obj = cache[key];\n\n        if (obj && (new Date().getTime() - obj.time) < 180000) {\n            return obj.value;\n        }\n\n        return null;\n    }\n\n    events.on(ConnectionManager, 'localusersignedin', clearCache);\n    events.on(ConnectionManager, 'localusersignedout', clearCache);\n\n    return {\n        getServerAddress: getServerAddress\n    };\n});\n"]}