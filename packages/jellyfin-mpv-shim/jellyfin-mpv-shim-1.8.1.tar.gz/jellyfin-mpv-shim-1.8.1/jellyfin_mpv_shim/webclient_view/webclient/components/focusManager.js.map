{"version":3,"sources":["components/focusManager.js"],"names":["define","dom","scrollManager","scopes","autoFocus","view","defaultToFirst","findAutoFocusElement","element","querySelector","getFocusableElements","focus","preventScroll","isEnabled","err","console","error","focusableTagNames","focusableContainerTagNames","focusableQuery","map","t","join","isFocusable","elem","indexOf","tagName","classList","contains","normalizeFocusable","originalElement","focusableParent","parent","parentNode","isCurrentlyFocusableInternal","offsetParent","getDefaultScope","document","body","limit","excludeClass","elems","querySelectorAll","focusableElements","i","length","push","isFocusContainer","direction","getOffset","box","getBoundingClientRect","top","left","width","height","right","bottom","nav","activeElement","container","getFocusContainer","nearestElement","focusableContainer","parentWithClass","rect","point1x","parseFloat","point1y","point2x","point2y","sourceMidX","Math","min","max","sourceMidY","focusable","minDistance","Infinity","curr","elementRect","distX","distY","x","y","x2","y2","intersectX","intersects","intersectY","midX","midY","abs","dist","sqrt","nearestElementFocusableParent","intersectsInternal","a1","a2","b1","b2","moveLeft","sourceElement","options","moveRight","moveUp","moveDown","sendText","text","value","isCurrentlyFocusable","disabled","getAttribute","type","pushScope","popScope","focusFirst","focusableSelector","focusLast","slice","call","reverse","moveFocus","offset","list","currentIndex","newIndex","newElem"],"mappings":"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","file":"focusManager.js","sourcesContent":["define(['dom', 'scrollManager'], function (dom, scrollManager) {\n    'use strict';\n\n    var scopes = [];\n    function pushScope(elem) {\n        scopes.push(elem);\n    }\n\n    function popScope(elem) {\n\n        if (scopes.length) {\n            scopes.length -= 1;\n        }\n    }\n\n    function autoFocus(view, defaultToFirst, findAutoFocusElement) {\n\n        var element;\n        if (findAutoFocusElement !== false) {\n            element = view.querySelector('*[autofocus]');\n            if (element) {\n                focus(element);\n                return element;\n            }\n        }\n\n        if (defaultToFirst !== false) {\n            element = getFocusableElements(view, 1, 'noautofocus')[0];\n\n            if (element) {\n                focus(element);\n                return element;\n            }\n        }\n\n        return null;\n    }\n\n    function focus(element) {\n\n        try {\n            element.focus({\n                preventScroll: scrollManager.isEnabled()\n            });\n        } catch (err) {\n            console.error('Error in focusManager.autoFocus: ' + err);\n        }\n    }\n\n    var focusableTagNames = ['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON', 'A'];\n    var focusableContainerTagNames = ['BODY', 'DIALOG'];\n    var focusableQuery = focusableTagNames.map(function (t) {\n\n        if (t === 'INPUT') {\n            t += ':not([type=\"range\"]):not([type=\"file\"])';\n        }\n        return t + ':not([tabindex=\"-1\"]):not(:disabled)';\n\n    }).join(',') + ',.focusable';\n\n    function isFocusable(elem) {\n\n        if (focusableTagNames.indexOf(elem.tagName) !== -1) {\n            return true;\n        }\n\n        if (elem.classList && elem.classList.contains('focusable')) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function normalizeFocusable(elem, originalElement) {\n        if (elem) {\n            var tagName = elem.tagName;\n            if (!tagName || tagName === 'HTML' || tagName === 'BODY') {\n                elem = originalElement;\n            }\n        }\n\n        return elem;\n    }\n\n    function focusableParent(elem) {\n\n        var originalElement = elem;\n\n        while (!isFocusable(elem)) {\n            var parent = elem.parentNode;\n\n            if (!parent) {\n                return normalizeFocusable(elem, originalElement);\n            }\n\n            elem = parent;\n        }\n\n        return normalizeFocusable(elem, originalElement);\n    }\n\n    // Determines if a focusable element can be focused at a given point in time\n    function isCurrentlyFocusableInternal(elem) {\n\n        // http://stackoverflow.com/questions/19669786/check-if-element-is-visible-in-dom\n        if (elem.offsetParent === null) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // Determines if a focusable element can be focused at a given point in time\n    function isCurrentlyFocusable(elem) {\n\n        if (elem.disabled) {\n            return false;\n        }\n\n        if (elem.getAttribute('tabindex') === '-1') {\n            return false;\n        }\n\n        if (elem.tagName === 'INPUT') {\n            var type = elem.type;\n            if (type === 'range') {\n                return false;\n            }\n            if (type === 'file') {\n                return false;\n            }\n        }\n\n        return isCurrentlyFocusableInternal(elem);\n    }\n\n    function getDefaultScope() {\n        return scopes[0] || document.body;\n    }\n\n    function getFocusableElements(parent, limit, excludeClass) {\n        var elems = (parent || getDefaultScope()).querySelectorAll(focusableQuery);\n        var focusableElements = [];\n\n        for (var i = 0, length = elems.length; i < length; i++) {\n\n            var elem = elems[i];\n\n            if (excludeClass && elem.classList.contains(excludeClass)) {\n                continue;\n            }\n\n            if (isCurrentlyFocusableInternal(elem)) {\n                focusableElements.push(elem);\n\n                if (limit && focusableElements.length >= limit) {\n                    break;\n                }\n            }\n        }\n\n        return focusableElements;\n    }\n\n    function isFocusContainer(elem, direction) {\n\n        if (focusableContainerTagNames.indexOf(elem.tagName) !== -1) {\n            return true;\n        }\n\n        var classList = elem.classList;\n\n        if (classList.contains('focuscontainer')) {\n            return true;\n        }\n\n        if (direction === 0) {\n            if (classList.contains('focuscontainer-x')) {\n                return true;\n            }\n            if (classList.contains('focuscontainer-left')) {\n                return true;\n            }\n        } else if (direction === 1) {\n            if (classList.contains('focuscontainer-x')) {\n                return true;\n            }\n            if (classList.contains('focuscontainer-right')) {\n                return true;\n            }\n        } else if (direction === 2) {\n            if (classList.contains('focuscontainer-y')) {\n                return true;\n            }\n        } else if (direction === 3) {\n            if (classList.contains('focuscontainer-y')) {\n                return true;\n            }\n            if (classList.contains('focuscontainer-down')) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function getFocusContainer(elem, direction) {\n        while (!isFocusContainer(elem, direction)) {\n            elem = elem.parentNode;\n\n            if (!elem) {\n                return getDefaultScope();\n            }\n        }\n\n        return elem;\n    }\n\n    function getOffset(elem) {\n\n        var box;\n\n        // Support: BlackBerry 5, iOS 3 (original iPhone)\n        // If we don't have gBCR, just use 0,0 rather than error\n        if (elem.getBoundingClientRect) {\n            box = elem.getBoundingClientRect();\n        } else {\n            box = {\n                top: 0,\n                left: 0,\n                width: 0,\n                height: 0\n            };\n        }\n\n        if (box.right === null) {\n\n            // Create a new object because some browsers will throw an error when trying to set data onto the Rect object\n            var newBox = {\n                top: box.top,\n                left: box.left,\n                width: box.width,\n                height: box.height\n            };\n\n            box = newBox;\n\n            box.right = box.left + box.width;\n            box.bottom = box.top + box.height;\n        }\n\n        return box;\n    }\n\n    function nav(activeElement, direction, container, focusableElements) {\n\n        activeElement = activeElement || document.activeElement;\n\n        if (activeElement) {\n            activeElement = focusableParent(activeElement);\n        }\n\n        container = container || (activeElement ? getFocusContainer(activeElement, direction) : getDefaultScope());\n\n        if (!activeElement) {\n            autoFocus(container, true, false);\n            return;\n        }\n\n        var focusableContainer = dom.parentWithClass(activeElement, 'focusable');\n\n        var rect = getOffset(activeElement);\n\n        // Get elements and work out x/y points\n        var cache = [];\n        var point1x = parseFloat(rect.left) || 0;\n        var point1y = parseFloat(rect.top) || 0;\n        var point2x = parseFloat(point1x + rect.width - 1) || point1x;\n        var point2y = parseFloat(point1y + rect.height - 1) || point1y;\n        // Shortcuts to help with compression\n        var min = Math.min;\n        var max = Math.max;\n\n        var sourceMidX = rect.left + (rect.width / 2);\n        var sourceMidY = rect.top + (rect.height / 2);\n\n        var focusable = focusableElements || container.querySelectorAll(focusableQuery);\n\n        var maxDistance = Infinity;\n        var minDistance = maxDistance;\n        var nearestElement;\n\n        for (var i = 0, length = focusable.length; i < length; i++) {\n            var curr = focusable[i];\n\n            if (curr === activeElement) {\n                continue;\n            }\n            // Don't refocus into the same container\n            if (curr === focusableContainer) {\n                continue;\n            }\n\n            //if (!isCurrentlyFocusableInternal(curr)) {\n            //    continue;\n            //}\n\n            var elementRect = getOffset(curr);\n\n            // not currently visible\n            if (!elementRect.width && !elementRect.height) {\n                continue;\n            }\n\n            switch (direction) {\n\n                case 0:\n                    // left\n                    if (elementRect.left >= rect.left) {\n                        continue;\n                    }\n                    if (elementRect.right === rect.right) {\n                        continue;\n                    }\n                    break;\n                case 1:\n                    // right\n                    if (elementRect.right <= rect.right) {\n                        continue;\n                    }\n                    if (elementRect.left === rect.left) {\n                        continue;\n                    }\n                    break;\n                case 2:\n                    // up\n                    if (elementRect.top >= rect.top) {\n                        continue;\n                    }\n                    if (elementRect.bottom >= rect.bottom) {\n                        continue;\n                    }\n                    break;\n                case 3:\n                    // down\n                    if (elementRect.bottom <= rect.bottom) {\n                        continue;\n                    }\n                    if (elementRect.top <= rect.top) {\n                        continue;\n                    }\n                    break;\n                default:\n                    break;\n            }\n\n            var x = elementRect.left;\n            var y = elementRect.top;\n            var x2 = x + elementRect.width - 1;\n            var y2 = y + elementRect.height - 1;\n\n            var intersectX = intersects(point1x, point2x, x, x2);\n            var intersectY = intersects(point1y, point2y, y, y2);\n\n            var midX = elementRect.left + (elementRect.width / 2);\n            var midY = elementRect.top + (elementRect.height / 2);\n\n            var distX;\n            var distY;\n\n            switch (direction) {\n\n                case 0:\n                    // left\n                    distX = Math.abs(point1x - Math.min(point1x, x2));\n                    distY = intersectY ? 0 : Math.abs(sourceMidY - midY);\n                    break;\n                case 1:\n                    // right\n                    distX = Math.abs(point2x - Math.max(point2x, x));\n                    distY = intersectY ? 0 : Math.abs(sourceMidY - midY);\n                    break;\n                case 2:\n                    // up\n                    distY = Math.abs(point1y - Math.min(point1y, y2));\n                    distX = intersectX ? 0 : Math.abs(sourceMidX - midX);\n                    break;\n                case 3:\n                    // down\n                    distY = Math.abs(point2y - Math.max(point2y, y));\n                    distX = intersectX ? 0 : Math.abs(sourceMidX - midX);\n                    break;\n                default:\n                    break;\n            }\n\n            var dist = Math.sqrt(distX * distX + distY * distY);\n\n            if (dist < minDistance) {\n                nearestElement = curr;\n                minDistance = dist;\n            }\n        }\n\n        if (nearestElement) {\n\n            // See if there's a focusable container, and if so, send the focus command to that\n            if (activeElement) {\n                var nearestElementFocusableParent = dom.parentWithClass(nearestElement, 'focusable');\n                if (nearestElementFocusableParent && nearestElementFocusableParent !== nearestElement) {\n                    if (focusableContainer !== nearestElementFocusableParent) {\n                        nearestElement = nearestElementFocusableParent;\n                    }\n                }\n            }\n            focus(nearestElement);\n        }\n    }\n\n    function intersectsInternal(a1, a2, b1, b2) {\n\n        return (b1 >= a1 && b1 <= a2) || (b2 >= a1 && b2 <= a2);\n    }\n\n    function intersects(a1, a2, b1, b2) {\n\n        return intersectsInternal(a1, a2, b1, b2) || intersectsInternal(b1, b2, a1, a2);\n    }\n\n    function sendText(text) {\n        var elem = document.activeElement;\n\n        elem.value = text;\n    }\n\n    function focusFirst(container, focusableSelector) {\n\n        var elems = container.querySelectorAll(focusableSelector);\n\n        for (var i = 0, length = elems.length; i < length; i++) {\n\n            var elem = elems[i];\n\n            if (isCurrentlyFocusableInternal(elem)) {\n                focus(elem);\n                break;\n            }\n        }\n    }\n\n    function focusLast(container, focusableSelector) {\n\n        var elems = [].slice.call(container.querySelectorAll(focusableSelector), 0).reverse();\n\n        for (var i = 0, length = elems.length; i < length; i++) {\n\n            var elem = elems[i];\n\n            if (isCurrentlyFocusableInternal(elem)) {\n                focus(elem);\n                break;\n            }\n        }\n    }\n\n    function moveFocus(sourceElement, container, focusableSelector, offset) {\n\n        var elems = container.querySelectorAll(focusableSelector);\n        var list = [];\n        var i;\n        var length;\n        var elem;\n\n        for (i = 0, length = elems.length; i < length; i++) {\n\n            elem = elems[i];\n\n            if (isCurrentlyFocusableInternal(elem)) {\n                list.push(elem);\n            }\n        }\n\n        var currentIndex = -1;\n\n        for (i = 0, length = list.length; i < length; i++) {\n\n            elem = list[i];\n\n            if (sourceElement === elem || elem.contains(sourceElement)) {\n                currentIndex = i;\n                break;\n            }\n        }\n\n        if (currentIndex === -1) {\n            return;\n        }\n\n        var newIndex = currentIndex + offset;\n        newIndex = Math.max(0, newIndex);\n        newIndex = Math.min(newIndex, list.length - 1);\n\n        var newElem = list[newIndex];\n        if (newElem) {\n            focus(newElem);\n        }\n    }\n\n    return {\n        autoFocus: autoFocus,\n        focus: focus,\n        focusableParent: focusableParent,\n        getFocusableElements: getFocusableElements,\n        moveLeft: function (sourceElement, options) {\n            var container = options ? options.container : null;\n            var focusableElements = options ? options.focusableElements : null;\n            nav(sourceElement, 0, container, focusableElements);\n        },\n        moveRight: function (sourceElement, options) {\n            var container = options ? options.container : null;\n            var focusableElements = options ? options.focusableElements : null;\n            nav(sourceElement, 1, container, focusableElements);\n        },\n        moveUp: function (sourceElement, options) {\n            var container = options ? options.container : null;\n            var focusableElements = options ? options.focusableElements : null;\n            nav(sourceElement, 2, container, focusableElements);\n        },\n        moveDown: function (sourceElement, options) {\n            var container = options ? options.container : null;\n            var focusableElements = options ? options.focusableElements : null;\n            nav(sourceElement, 3, container, focusableElements);\n        },\n        sendText: sendText,\n        isCurrentlyFocusable: isCurrentlyFocusable,\n        pushScope: pushScope,\n        popScope: popScope,\n        focusFirst: focusFirst,\n        focusLast: focusLast,\n        moveFocus: moveFocus\n    };\n});\n"]}